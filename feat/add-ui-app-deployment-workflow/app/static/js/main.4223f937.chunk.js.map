{"version":3,"sources":["hooks/accounts/queries/useGetAccountsQuery.tsx","hooks/accounts/usePersistActiveAccount.tsx","hooks/accounts/resolvers/useSetActiveAccountMutationResolver.tsx","hooks/accounts/useSetActiveAccount.tsx","hooks/accounts/resolvers/useAccountsMutationResolvers.tsx","hooks/polkadotJs/typesConfig.tsx","hooks/config/usePersistentConfig.tsx","hooks/polkadotJs/usePolkadotJs.tsx","hooks/balances/useBalanceQueryResolvers.tsx","hooks/balances/useGetBalancesByAddress.tsx","hooks/vesting/useVestingScheduleQueryResolvers.tsx","hooks/vesting/useGetVestingScheduleByAddress.tsx","hooks/accounts/resolvers/useGetAccountsQueryResolver.tsx","hooks/accounts/useGetAccounts.tsx","hooks/lastBlock/useLastBlockQuery.tsx","hooks/lastBlock/useSubscribeNewBlockNumber.tsx","hooks/lastBlock/useRefetchWithNewBlock.tsx","hooks/config/useGetConfigQuery.tsx","hooks/accounts/queries/useGetActiveAccountQuery.tsx","hooks/vesting/useVestingMutationResolvers.tsx","hooks/balances/useBalanceMutationResolvers.tsx","hooks/polkadotJs/useExtensionQueryResolvers.tsx","hooks/config/useConfigQueryResolvers.tsx","hooks/config/useConfigMutationResolver.tsx","hooks/feePaymentAssets/useFeePaymentAssetsQueryResolvers.tsx","hooks/apollo/useApollo.tsx","hooks/accounts/resolvers/useAccountsQueryResolvers.tsx","hooks/polkadotJs/useGetExtensionQuery.tsx","containers/MultiProvider.tsx","hooks/accounts/mutations/useSetActiveAccountMutation.tsx","hooks/vesting/useClaimVestedAmountMutation.tsx","hooks/balances/useTransferBalanceMutation.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["GET_ACCOUNTS","usePersistedActiveAccount","createPersistedState","usePersistActiveAccount","undefined","useSetActiveAccountMutationResolver","setActiveAccount","setPersistedActiveAccount","useCallback","client","address","a","accountsData","cache","readQuery","query","accounts","map","account","isActive","id","activeAccount","find","writeQuery","data","lastBlock","Promise","resolve","setTimeout","useSetActiveAccount","useResolverToRef","_obj","args","resolver","name","resolverRef","useRef","useEffect","current","log","debug","apply","arguments","defaultConfigValue","nodeUrl","processorUrl","appName","usePersistedConfig","usePersistentConfig","constate","useState","apiInstance","setApiInstance","loading","useMemo","provider","WsProvider","types","typesConfig","ormlTypes","typesAlias","ormlTypesAlias","ApiPromise","create","api","isReady","disconnect","PolkadotJsProvider","usePolkadotJsContext","useBalanceQueryResolvers","getBalancesByAddress","console","balances","system","nativeAssetBalance","push","assetId","balance","free","toString","tokens","entries","assetBalances","forEach","assetBalanceTuple","toHuman","createType","useGetBalancesByAddress","useVestingScheduleQueryResolvers","getVestingScheduleByAddress","first","vesting","vestingSchedules","vestingSchedule","locks","lockedAmount","eq","lockedVestingAmount","remainingVestingAmount","amount","start","period","periodCount","perPeriod","useGetVestingScheduleByAddress","__typename","useGetAccountsResolver","persistedActiveAccount","getAccounts","persistedActiveAccountId","web3Enable","web3Accounts","encodeAddress","decodeAddress","meta","isArray","GET_LAST_BLOCK","lastBlockNumber","setLastBlockNumber","subscribeNewBlocks","derive","chain","block","header","number","LastBlockNumberProvider","useLastBlockNumberContext","writeLastBlock","GET_CONFIG","GET_ACTIVE_ACCOUNT","useGetActiveAccountQuery","useApolloClient","result","useQuery","notifyOnNetworkStatusChange","refetchQueries","include","withGracefulErrors","fn","errorHandlers","reject","reduce","e","errorHandler","gracefulExtensionCancelationErrorHandler","message","error","vestingClaimHandler","status","dispatchError","isFinalized","info","isInBlock","isModule","isBroadcast","polkadotJsNotReadyYetError","useVestingMutationResolvers","claimVestedAmount","variables","Error","web3FromAddress","signer","tx","claim","signAndSend","transferBalanceHandler","registry","findMetaError","asModule","transferBalanceExtrinsic","currencies","transfer","useBalanceMutationResolvers","transferBalance","from","to","currencyId","useConfigQueryResolvers","persistedConfig","config","_variables","multiTransactionPayment","accountCurrencyMap","feePaymentAsset","setCurrencyHandler","useConfigMutationResolvers","setPersistedConfig","setConfig","setCurrency","persistableConfig","useFeePaymentAssetsQueryResolvers","feePaymentAssets","acceptedCurrencies","acceptedCurrency","fallbackPrice","useResolvers","Query","Account","AccountsQueryResolver","extension","extensions","isAvailable","length","Mutation","typeDefs","useConfigureApolloClient","resolvers","InMemoryCache","ApolloClient","uri","connectToDevTools","queryDeduplication","lastBlockData","updateCache","useRefetchWithNewBlock","GET_EXTENSION","useLazyQuery","GetExtensionQueryProvider","ConfiguredApolloProvider","children","ApolloProvider","QueryProvider","MultiProvider","SET_ACTIVE_ACCOUNT","CLAIM_VESTED_AMOUNT","TRANSFER_BALANCE","setLevel","AccountDisplay","useMutation","useClaimVestedAmountMutation","claimLoading","transferBalanceVariables","useTransferBalanceMutation","paymentInfo","setPaymentInfo","estimatePaymentInfo","useEstimateTransferBalance","onClick","_","partialFee","i","Accounts","refetch","networkStatus","Page","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.4223f937.chunk.js","sourcesContent":["import { useQuery } from '@apollo/client'\nimport { Query } from '../../../generated/graphql';\nimport { loader } from 'graphql.macro';\n\nexport const GET_ACCOUNTS = loader('./../graphql/GetAccounts.query.graphql');\nexport interface GetAccountsQueryResponse {\n    accounts: Query['accounts'],\n    lastBlock: Query['lastBlock']\n}\n\nexport const useGetAccountsQuery = () => useQuery<GetAccountsQueryResponse>(GET_ACCOUNTS, {\n    notifyOnNetworkStatusChange: true\n});","import { useLocalStorage } from 'react-use';\nimport { Account } from '../../generated/graphql';\nimport createPersistedState from 'use-persisted-state';\n\nexport const key = 'basilisk-active-account';\nexport const defaultValue = undefined;\nexport interface PersistedAccount {\n    id: string\n}\n\n// we're not using react-use/useLocalStorage since i couldn't figure out\n// why it would not trigger effects when the local storage updates\nconst usePersistedActiveAccount = createPersistedState(key);\nexport const usePersistActiveAccount = () => usePersistedActiveAccount<PersistedAccount | undefined>(defaultValue);","import { ApolloClient, NormalizedCacheObject } from '@apollo/client';\nimport { useCallback } from 'react';\nimport { useSetActiveAccount } from '../useSetActiveAccount'\nimport { SetActiveAccountMutationVariables } from '../mutations/useSetActiveAccountMutation';\nimport { useResolverToRef } from './useAccountsMutationResolvers';\n\nexport const useSetActiveAccountMutationResolver = () => {\n    const setActiveAccount = useSetActiveAccount();\n    \n    return useResolverToRef(\n        useCallback(async (\n            _obj,\n            args: SetActiveAccountMutationVariables,\n            { client }: { client: ApolloClient<NormalizedCacheObject> }\n        ) => setActiveAccount(client, args.id), [setActiveAccount]),\n        'setActiveAccount'\n    )\n}","import { ApolloClient, NormalizedCacheObject, useApolloClient } from '@apollo/client';\nimport { find } from 'lodash';\nimport { useCallback } from 'react';\nimport { GetAccountsQueryResponse, GET_ACCOUNTS } from './queries/useGetAccountsQuery';\nimport { usePersistActiveAccount } from './usePersistActiveAccount';\n\nexport const useSetActiveAccount = () => {\n    const [_persistedActiveAccount, setPersistedActiveAccount] = usePersistActiveAccount();\n\n    return useCallback(async (\n        client: ApolloClient<NormalizedCacheObject>,\n        address: string | undefined\n    ) => {\n        const accountsData = client.cache?.readQuery<GetAccountsQueryResponse>({\n            query: GET_ACCOUNTS,\n        });\n\n        if (!accountsData?.accounts) return;\n\n        const accounts = accountsData.accounts\n            .map(account => ({\n                ...account,\n                isActive: account.id === address ? true : false\n            }))\n        \n        const activeAccount = find(accounts, { isActive: true });\n        activeAccount\n            ? setPersistedActiveAccount({\n                id: activeAccount.id\n            })\n            : setPersistedActiveAccount(undefined)\n        \n        //TODO: return the data to be mutated from the mutation instead\n        client.cache?.writeQuery<GetAccountsQueryResponse>({\n            query: GET_ACCOUNTS,\n            data: { accounts, lastBlock: accountsData.lastBlock }\n        });\n\n        // wait for the local storage changes before finishing the mutation\n        // TODO: find a better way to wait until the local storage changes are\n        // propagated to the resolverRef\n        await (new Promise(resolve => setTimeout(resolve, 0)));\n    }, [ \n        setPersistedActiveAccount\n    ])\n}","import { ApolloCache, ApolloClient, NormalizedCacheObject, Resolver } from '@apollo/client'\nimport { find } from 'lodash';\nimport { useCallback, useEffect, useRef } from 'react';\nimport { SetActiveAccountMutationVariables } from '../mutations/useSetActiveAccountMutation'\nimport log from 'loglevel';\nimport { useSetActiveAccount } from '../useSetActiveAccount';\nimport { useSetActiveAccountMutationResolver } from './useSetActiveAccountMutationResolver';\n\n/**\n * Updates the resolver fn ref each time the given resolver fn changes.\n * \n * This is necessary to reflect changes made to functions within hooks\n * within the Apollo resolvers configuration. \n */\nexport const useResolverToRef = (resolver: Resolver, name?: string) => {\n    const resolverRef = useRef(resolver);\n    // when the resolver changes, update the ref\n    useEffect(() => { resolverRef.current = resolver }, [resolver]);\n\n    return function resolverFromRef() {\n        // TODO is there a better way to debug resolvers? Since the function name\n        // is not visible in the apollo error\n        log.debug('Running resolver', name);\n        // execute the wrapper resolver ref, with the given arguments from Apollo\n        return resolverRef.current.apply(undefined, arguments as any);\n    }\n}\n\n/**\n * Used to resolve mutations regarding the Account entity\n * @returns \n */\nexport const useAccountsMutationResolvers = () => {\n    const setActiveAccountMutationResolver = useSetActiveAccountMutationResolver();\n\n    return {\n        setActiveAccount: setActiveAccountMutationResolver\n    }\n}","export default {\n    \"alias\": {\n      \"tokens\": {\n        \"AccountData\": \"OrmlAccountData\"\n      }\n    },\n    \"types\": [\n      {\n        \"AssetPair\": {\n          \"asset_in\": \"AssetId\",\n          \"asset_out\": \"AssetId\"\n        },\n        \"Amount\": \"i128\",\n        \"AmountOf\": \"Amount\",\n        \"Address\": \"AccountId\",\n        \"OrmlAccountData\": {\n          \"free\": \"Balance\",\n          \"frozen\": \"Balance\",\n          \"reserved\": \"Balance\"\n        },\n        \"Fee\": {\n          \"numerator\": \"u32\",\n          \"denominator\": \"u32\"\n        },\n        \"BalanceInfo\": {\n          \"amount\": \"Balance\",\n          \"assetId\": \"AssetId\"\n        },\n        \"Chain\": {\n          \"genesisHash\": \"Vec<u8>\",\n          \"lastBlockHash\": \"Vec<u8>\"\n        },\n        \"Currency\": \"AssetId\",\n        \"CurrencyId\": \"AssetId\",\n        \"CurrencyIdOf\": \"AssetId\",\n        \"Intention\": {\n          \"who\": \"AccountId\",\n          \"asset_sell\": \"AssetId\",\n          \"asset_buy\": \"AssetId\",\n          \"amount\": \"Balance\",\n          \"discount\": \"bool\",\n          \"sell_or_buy\": \"IntentionType\"\n        },\n        \"IntentionId\": \"Hash\",\n        \"IntentionType\": {\n          \"_enum\": [\n            \"SELL\",\n            \"BUY\"\n          ]\n        },\n        \"LookupSource\": \"AccountId\",\n        \"Price\": \"Balance\",\n        \"ClassId\": \"u64\",\n        \"TokenId\": \"u64\",\n        \"ClassData\": {\n          \"is_pool\": \"bool\"\n        },\n        \"TokenData\": {\n          \"locked\": \"bool\"\n        },\n        \"ClassInfo\": {\n          \"metadata\": \"Vec<u8>\",\n          \"total_issuance\": \"TokenId\",\n          \"owner\": \"AccountId\",\n          \"data\": \"ClassData\"\n        },\n        \"TokenInfo\": {\n          \"metadata\": \"Vec<u8>\",\n          \"owner\": \"AccountId\",\n          \"data\": \"TokenData\"\n        },\n        \"ClassInfoOf\": \"ClassInfo\",\n        \"TokenInfoOf\": \"TokenInfo\",\n        \"ClassIdOf\": \"ClassId\",\n        \"TokenIdOf\": \"TokenId\",\n        \"OrderedSet\": \"Vec<AssetId>\",\n        \"VestingSchedule\": {\n          \"start\": \"BlockNumber\",\n          \"period\": \"BlockNumber\",\n          \"period_count\": \"u32\",\n          \"per_period\": \"Compact<Balance>\"\n        },\n        \"VestingScheduleOf\": \"VestingSchedule\",\n        \"LBPWeight\": \"u32\",\n        \"WeightCurveType\": {\n          \"_enum\": [\n            \"Linear\"\n          ]\n        },\n        \"PoolId\": \"AccountId\",\n        \"BalanceOf\": \"Balance\",\n        \"AssetType\": {\n          \"_enum\": {\n            \"Token\": \"Null\",\n            \"PoolShare\": \"(AssetId,AssetId)\"\n          }\n        },\n        \"Pool\": {\n          \"owner\": \"AccountId\",\n          \"start\": \"BlockNumber\",\n          \"end\": \"BlockNumber\",\n          \"assets\": \"AssetPair\",\n          \"initial_weight\": \"LBPWeight\",\n          \"final_weight\": \"LBPWeight\",\n          \"weight_curve\": \"WeightCurveType\",\n          \"fee\": \"Fee\",\n          \"fee_collector\": \"AccountId\"\n        },\n        \"AssetDetails\": {\n          \"name\": \"Vec<u8>\",\n          \"asset_type\": \"AssetType\",\n          \"existential_deposit\": \"Balance\",\n          \"locked\": \"bool\"\n        },\n        \"AssetDetailsT\": \"AssetDetails\",\n        \"AssetMetadata\": {\n          \"symbol\": \"Vec<u8>\",\n          \"decimals\": \"u8\"\n        },\n        \"AssetInstance\": \"AssetInstanceV1\",\n        \"MultiLocation\": \"MultiLocationV1\",\n        \"AssetNativeLocation\": \"MultiLocation\",\n        \"MultiAsset\": \"MultiAssetV1\",\n        \"Xcm\": \"XcmV1\",\n        \"XcmOrder\": \"XcmOrderV1\"\n      }\n    ]\n  };","import createPersistedState from 'use-persisted-state';\nimport { Config } from '../../generated/graphql';\n\nconst key = 'basilisk-config';\nexport const defaultConfigValue = {\n    nodeUrl: 'ws://localhost:9988',\n    processorUrl: '/graphql',\n    appName: 'basilisk-ui'\n};\n\n// TODO: write apollo integration for querying and mutating the config\nconst usePersistedConfig = createPersistedState(key)\nexport const usePersistentConfig = () => usePersistedConfig<Config>(defaultConfigValue);","import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { ProviderInterface } from '@polkadot/rpc-provider/types'\nimport { useMemo, useState, useEffect } from 'react';\nimport constate from 'constate';\nimport typesConfig from './typesConfig';\nimport { usePersistentConfig } from '../config/usePersistentConfig';\nimport { types as ormlTypes, typesAlias as ormlTypesAlias } from '@open-web3/orml-type-definitions'\n\n\n\n\n/**\n * Setup an instance of PolkadotJs, and watch\n * for config updates. In case the nodeUrl changes,\n * then re-create the PolkadotJs instance\n */\nexport const useConfigurePolkadotJs = () => {\n  const [{ nodeUrl }] = usePersistentConfig();\n  const [apiInstance, setApiInstance] = useState<ApiPromise | undefined>(undefined);\n  const loading = useMemo(() => apiInstance ? false : true, [apiInstance]);\n  const provider = useMemo(() => new WsProvider(nodeUrl), [nodeUrl]);\n\n  const types = useMemo(() => ({\n    ...typesConfig.types[0],\n    ...ormlTypes,\n  }), []);\n\n  const typesAlias = useMemo(() => ({\n    ...typesConfig.alias,\n    ...ormlTypesAlias\n  }), []);\n\n  // (re-)Create the PolkadotJS instance, when the provider updates.\n  useEffect(() => {\n    (async () => {\n      setApiInstance(undefined);\n      const api = await ApiPromise.create({\n        provider,\n        types,\n        typesAlias\n      });\n      await api.isReady;\n      setApiInstance(api);\n    })();\n\n    // when the component using the usePolkadot hook unmounts, disconnect the websocket\n    return () => {\n      apiInstance?.disconnect();\n    };\n  }, [provider]);\n\n  return { apiInstance, loading };\n};\n\n// TODO: lift to context using constate\n// export const usePolkadotJs = () => useConfigurePolkadotJs();\nexport const [PolkadotJsProvider, usePolkadotJsContext] = constate(useConfigurePolkadotJs);","import { useCallback } from 'react'\nimport { Account } from '../../generated/graphql';\nimport { useResolverToRef } from '../accounts/resolvers/useAccountsMutationResolvers'\nimport { useGetBalancesByAddress } from './useGetBalancesByAddress';\n\nexport const useBalanceQueryResolvers = () => {\n    const getBalancesByAddress = useGetBalancesByAddress();\n    const balances = useResolverToRef(\n        useCallback(\n            async (account: Account) => await getBalancesByAddress(account.id), \n            [getBalancesByAddress]\n        ),\n        'balances'\n    );\n\n    return {\n        balances\n    }\n}","import { Codec } from '@polkadot/types/types';\nimport { useCallback, useEffect } from 'react';\nimport { Balance } from '../../generated/graphql';\nimport { usePolkadotJsContext } from '../polkadotJs/usePolkadotJs';\n\nexport const nativeAssetId = '0';\nexport const assetBalanceDataType = 'AccountData';\nexport const useGetBalancesByAddress = () => {\n    const { apiInstance, loading } = usePolkadotJsContext()\n\n    const getBalancesByAddress = useCallback(async (address: string) => {\n        console.log('getting balance', address);\n        if (!apiInstance) return;\n\n        const balances: Balance[] = [];\n        const nativeAssetBalance = await apiInstance.query.system.account(address);    \n\n        balances.push({\n            assetId: nativeAssetId,\n            balance: nativeAssetBalance?.data.free.toString()\n        });\n\n        // TODO: write type definitions for `query.tokens`\n        const assetBalances = await apiInstance.query.tokens.accounts.entries(address);\n\n        assetBalances?.forEach(assetBalanceTuple => {\n            const assetIdTuple = assetBalanceTuple[0].toHuman() as string[];\n            const assetId = assetIdTuple[1];\n\n            const balance = apiInstance?.createType(\n                assetBalanceDataType,\n                assetBalanceTuple[1]\n            ).free.toString();\n\n            balances.push({ assetId, balance });\n        });\n\n        return balances;\n    }, [apiInstance, loading]);\n\n    return getBalancesByAddress;\n}","import { useCallback } from 'react'\nimport { Account } from '../../generated/graphql';\nimport { useResolverToRef } from '../accounts/resolvers/useAccountsMutationResolvers'\nimport { useGetVestingScheduleByAddress } from './useGetVestingScheduleByAddress';\n\nexport const useVestingScheduleQueryResolvers = () => {\n    const getVestingScheduleByAddress = useGetVestingScheduleByAddress();\n    const vestingSchedule = useResolverToRef(\n        useCallback(\n            async (account: Account) => await getVestingScheduleByAddress(account.id), \n            [getVestingScheduleByAddress]\n        ),\n        'vestingSchedule'\n    );\n\n    return {\n        vestingSchedule\n    }\n}","import { useCallback } from 'react';\nimport { usePolkadotJsContext } from '../polkadotJs/usePolkadotJs'\nimport { Vec } from '@polkadot/types';\nimport { VestingScheduleOf } from '@open-web3/orml-types/interfaces'\nimport { find, first } from 'lodash';\n\nexport const vestingBalanceDataType = 'Vec<BalanceLock>';\nexport const vestingBalanceLockId = 'ormlvest';\n\nexport const vestingScheduleDataType = 'Vec<VestingScheduleOf>';\n\nexport const useGetVestingScheduleByAddress = () => {\n    const { apiInstance, loading } = usePolkadotJsContext();\n\n    const getVestingScheduleByAddress = useCallback(async (address: string) => {\n        if (!apiInstance) return;\n\n        // TODO: instead of multiple .createType calls, use the following\n        // https://github.com/AcalaNetwork/acala.js/blob/9634e2291f1723a84980b3087c55573763c8e82e/packages/sdk-core/src/functions/getSubscribeOrAtQuery.ts#L4\n        const vestingSchedule = first(\n            apiInstance.createType(\n                vestingScheduleDataType,\n                await apiInstance.query.vesting.vestingSchedules(address)\n            ) as Vec<VestingScheduleOf>\n        );\n\n        const lockedVestingAmount = find(\n            apiInstance.createType(\n                vestingBalanceDataType,\n                await apiInstance.query.balances.locks(address)\n            ),\n            lockedAmount => (\n                lockedAmount.id.eq(vestingBalanceLockId)\n            )\n        );\n        \n        // TODO: are we sure this really conforms with the graphql VestingSchedule type\n        // in all conditions?\n        return {\n            // TODO: add a claimableAmount (https://gist.github.com/maht0rz/53466af0aefba004d5a4baad23f8ce26)\n            remainingVestingAmount: lockedVestingAmount?.amount.toString(),\n            start: vestingSchedule?.start.toString(),\n            period: vestingSchedule?.period.toString(),\n            periodCount: vestingSchedule?.periodCount.toString(),\n            perPeriod: vestingSchedule?.perPeriod.toString()\n        }\n\n    }, [apiInstance, loading]);\n\n    return getVestingScheduleByAddress;\n}","import { isArray } from 'lodash';\nimport { useCallback } from 'react';\nimport { useGetAccounts } from '../useGetAccounts';\nimport { usePersistActiveAccount } from '../usePersistActiveAccount';\nimport { useResolverToRef } from './useAccountsMutationResolvers';\n\nexport interface AccountsQueryResolverArgs {\n    isActive?: boolean\n}\n\nexport const __typename = 'Account';\n\nexport const useGetAccountsResolver = () => {\n    const [persistedActiveAccount] = usePersistActiveAccount();\n    const getAccounts = useGetAccounts();\n\n    return useResolverToRef(\n        useCallback(async (\n            _obj,\n            args: AccountsQueryResolverArgs \n        ) => {\n            const accounts = await getAccounts(\n                persistedActiveAccount?.id,\n                args?.isActive,\n            );\n    \n            return isArray(accounts)\n                ? accounts.map(account => ({\n                    ...account,\n                    __typename\n                }))\n                : ({\n                    // just a single account\n                    ...accounts,\n                    __typename\n                })\n        }, [\n            persistedActiveAccount,\n            getAccounts\n        ]),\n        'accounts'\n    )\n}","import { web3Accounts, web3Enable } from '@polkadot/extension-dapp';\nimport { encodeAddress, decodeAddress } from '@polkadot/util-crypto';\nimport { find } from 'lodash';\nimport { useCallback } from 'react';\nimport { PersistedAccount } from './usePersistActiveAccount';\n\n// prefix for the ss58 address formatting of substrate addresses\nexport const basiliskAddressPrefix = 10041;\n\n/**\n * Used to fetch either all accounts, or accounts matching the given\n * set of parameters e.g. 'isActive'.\n */\nexport const useGetAccounts = () => useCallback(async (\n    persistedActiveAccountId: string | undefined,\n    isActive: boolean | undefined\n) => {\n    // TODO: use `config.appName`\n    // ensure we're connected to the polkadot.js extension\n    await web3Enable('basilisk-ui');\n\n    // get all the accounts from the polkadot.js extension\n    const accounts = (await web3Accounts())\n        // transform the returned accounts into the required entity format\n        .map(account => {\n            const address = encodeAddress(decodeAddress(account.address), basiliskAddressPrefix)\n            return {\n                id: address,\n                name: account.meta.name,\n                isActive: false,\n            };\n        })\n        // mark the active account based on the current persisted account\n        .map(account => ({\n            ...account,\n            isActive: persistedActiveAccountId == account.id,\n        }))\n\n    // if we're filtering for an active account, return just the single active account\n    if (isActive) {\n        const account = find(accounts, { isActive: isActive })\n        return account;\n    }   \n\n    // return all retrieved accounts\n    return accounts;\n}, []);","import { useQuery } from '@apollo/client';\nimport { loader } from 'graphql.macro';\nimport { LastBlock, Query } from '../../generated/graphql';\n\n\nexport const GET_LAST_BLOCK = loader('./graphql/GetLastBlock.query.graphql');\nexport interface GetLastBlockQueryResponse {\n    lastBlock: Query['lastBlock']\n}\n\nexport const useLastBlockQuery = () => useQuery<GetLastBlockQueryResponse>(GET_LAST_BLOCK);","import constate from 'constate';\nimport { useCallback, useEffect, useState } from 'react';\nimport { usePolkadotJsContext } from '../polkadotJs/usePolkadotJs'\n\n// TODO: lift up using constate\nexport const useSubscribeNewBlockNumber = () => {\n    const { apiInstance, loading } = usePolkadotJsContext();\n    const [lastBlockNumber, setLastBlockNumber] = useState<string | undefined>(undefined);\n\n    const subscribeNewBlocks = useCallback(() => {\n        if (!apiInstance) return;\n        // TODO: how to unsubscribe?\n        apiInstance.derive.chain\n            .subscribeNewBlocks((block) => {\n                setLastBlockNumber(block.block.header.number.toString())\n            })\n\n    }, [apiInstance]);\n\n    useEffect(() => {\n        if (loading) return;\n        subscribeNewBlocks();\n    }, [loading, subscribeNewBlocks])\n\n    return lastBlockNumber;\n}\n\nexport const [LastBlockNumberProvider, useLastBlockNumberContext] = constate(useSubscribeNewBlockNumber);","import { ApolloCache, ApolloClient, NormalizedCacheObject, useApolloClient } from '@apollo/client';\nimport { relativeTimeRounding } from 'moment';\nimport { useEffect } from 'react';\nimport { LastBlock } from '../../generated/graphql';\nimport { GetLastBlockQueryResponse, GET_LAST_BLOCK } from './useLastBlockQuery';\nimport { useLastBlockNumberContext, useSubscribeNewBlockNumber } from './useSubscribeNewBlockNumber'\n\nexport const __typename = 'LastBlock';\nexport const id = __typename;\n\nexport const writeLastBlock = (cache: ApolloCache<NormalizedCacheObject>, lastBlock: LastBlock) => {\n    return cache.writeQuery<GetLastBlockQueryResponse>({\n        query: GET_LAST_BLOCK,\n        data: {\n            lastBlock\n        }\n    })\n}\nexport const useRefetchWithNewBlock = (client: ApolloClient<NormalizedCacheObject>) => {\n    const lastBlockNumber = useLastBlockNumberContext();\n\n    useEffect(() => {\n        writeLastBlock(client.cache, {\n            __typename,\n            id,\n            number: lastBlockNumber\n        });\n    }, []);\n\n    useEffect(() => {\n        if (!lastBlockNumber) return;\n\n        const lastBlockData = client.cache.readQuery<GetLastBlockQueryResponse>({\n            query: GET_LAST_BLOCK\n        });\n\n        if (!lastBlockData?.lastBlock?.number) {\n            // received the first real lastBlockNumber, don't refetch just yet\n            writeLastBlock(client.cache, {\n                __typename,\n                id,\n                number: lastBlockNumber\n            })\n        } else {\n            // lastBlockNumber has been updated, and it's not the first time\n            // refetch queries that depend on the lastBlockNumber\n            client.refetchQueries({\n                updateCache(cache) {\n                    writeLastBlock(cache, {\n                        __typename,\n                        id,\n                        number: lastBlockNumber\n                    })\n                }\n            })\n        }\n    }, [lastBlockNumber]);\n}","import { useQuery } from '@apollo/client';\nimport { loader } from 'graphql.macro';\nimport { Query } from '../../generated/graphql';\n\nexport const GET_CONFIG = loader('./graphql/GetConfig.query.graphql');\n\nexport interface GetConfigQueryResponse {\n    config: Query['config']\n}\n\nexport const useGetConfigQuery = () => useQuery<GetConfigQueryResponse>(GET_CONFIG, {\n    notifyOnNetworkStatusChange: true\n});","import { useApolloClient, useQuery } from '@apollo/client';\nimport constate from 'constate';\nimport { loader } from 'graphql.macro'\nimport { useEffect } from 'react';\nimport { Account, LastBlock, Query } from '../../../generated/graphql';\nimport { GET_CONFIG } from '../../config/useGetConfigQuery';\n\nexport const GET_ACTIVE_ACCOUNT = loader('./../graphql/GetActiveAccount.query.graphql');\n\nexport interface GetActiveAccountQueryResponse {\n    account: Query['account'],\n    lastBlock: Query['lastBlock'],\n}\n\n// TODO: turn this into a lazy query instead, so it does not get fetched right away\nexport const useGetActiveAccountQuery = () => {\n    const client = useApolloClient();\n    const result = useQuery<GetActiveAccountQueryResponse>(GET_ACTIVE_ACCOUNT, {\n        notifyOnNetworkStatusChange: true,\n    });\n\n    // when the active account updates, refetch the config\n    // since the config for `feePaymentAsset` depends on the active account\n    useEffect(() => {\n        client.refetchQueries({\n            include: [GET_CONFIG]\n        });\n    }, [result.data?.account?.id])\n\n    return result;\n}\nexport const [GetActiveAccountQueryProvider, useGetActiveAccountQueryContext] = constate(useGetActiveAccountQuery);","import { useCallback } from 'react'\nimport { useResolverToRef } from '../accounts/resolvers/useAccountsMutationResolvers'\nimport { usePolkadotJsContext } from '../polkadotJs/usePolkadotJs'\nimport { web3FromAddress } from '@polkadot/extension-dapp';\nimport { ClaimVestedAmountMutationVariables } from './useClaimVestedAmountMutation';\nimport { ExtrinsicStatus } from '@polkadot/types/interfaces/author';\nimport { DispatchError } from '@polkadot/types/interfaces/system';\nimport log from 'loglevel';\nimport { ApolloCache, NormalizedCacheObject } from '@apollo/client';\nimport { GetActiveAccountQueryResponse, GET_ACTIVE_ACCOUNT } from '../accounts/queries/useGetActiveAccountQuery';\n\n/**\n * Run an async function and handle the thrown errors\n * with an array of error handlers, which may handle the errors gracefully\n * \n * @param fn \n * @param errorHandlers \n * @returns \n */\nexport type resolve = (result?: any) => void;\nexport type reject = (error?: any) => void;\nexport const withGracefulErrors = async (\n    fn: (resolve: resolve, reject: reject) => Promise<any>,\n    errorHandlers: ((error: any) => void)[]\n) => {\n    return new Promise<any>(async (resolve, reject) => {\n        try {\n            resolve(await fn(resolve, reject));\n        } catch (e: any) {\n            e = errorHandlers.reduce((e, errorHandler) => errorHandler(e), e);\n            // rejecting this promise with an error instead of throwing an error\n            // is necessary to reflect the apollo resolver loading state correctly\n            e ? reject(e) : resolve(null)\n        }\n    })\n}\n\nexport const cancelledErrorMessage = 'Cancelled';\n\n/**\n * This is an example graceful error handler,\n * if this would return `e` instead of `void`,\n * then the following graceful error handler would be triggered,\n * or by default the error would be thrown.\n * \n * @param e\n * @returns \n */\nexport const gracefulExtensionCancelationErrorHandler = (e: any) => {\n    if ((e as Error)?.message === cancelledErrorMessage) {\n        log.error('Operation presumably cancelled by the user in the Polkadot.js extension')\n        return;\n    }\n    return e;\n}\n\nexport const vestingClaimHandler = (resolve: resolve, reject: reject) => ({\n    status,\n    dispatchError\n}: {\n    status: ExtrinsicStatus,\n    dispatchError?: DispatchError\n}) => {\n    console.log('status', status);\n    if (status.isFinalized) log.info('operation finalized')\n\n    // TODO: handle status via the action log / notification stack\n    if (status.isInBlock) {\n        if (dispatchError?.isModule) {\n            return log.info('operation unsuccessful', dispatchError);\n        }\n\n        return log.info('operation successful');\n    }\n\n    // if the operation has been broadcast, finish the mutation\n    if (status.isBroadcast) {\n        log.info('transaction has been broadcast');\n        return resolve();\n    }\n    if (dispatchError) {\n        log.error('There was a dispatch error', dispatchError);\n        return reject();\n    }\n};\n\nexport const noAccountSelectedError = 'No Account selected';\nexport const polkadotJsNotReadyYetError = 'Polkadot.js is not ready yet';\n\nexport const useVestingMutationResolvers = () => {\n    const { apiInstance, loading } = usePolkadotJsContext();\n\n    const claimVestedAmount = useResolverToRef(\n        useCallback(async (\n            _obj,\n            variables: ClaimVestedAmountMutationVariables,\n            { cache }: { cache: ApolloCache<NormalizedCacheObject> }\n        ) => {\n            const address = variables?.address\n                ? variables.address\n                : cache.readQuery<GetActiveAccountQueryResponse>({\n                    query: GET_ACTIVE_ACCOUNT\n                })?.account?.id;\n\n            // TODO: error handling?\n            if (!address) throw new Error(noAccountSelectedError);\n            if (loading || !apiInstance) throw new Error(polkadotJsNotReadyYetError);\n\n            // // TODO: why does this not return a tx hash?\n            return await withGracefulErrors(async (resolve, reject) => {\n                const { signer } = await web3FromAddress(address);\n                await apiInstance.tx.vesting.claim()\n                    .signAndSend(\n                        address,\n                        { signer },\n                        vestingClaimHandler(resolve, reject)\n                    )\n            }, [\n                gracefulExtensionCancelationErrorHandler\n            ])\n\n        }, [loading, apiInstance]),\n        'claimVestedAmount'\n    )\n\n    return {\n        claimVestedAmount\n    }\n}","import { web3FromAddress } from '@polkadot/extension-dapp';\nimport { useCallback, useEffect, useMemo, useState } from 'react';\nimport { useResolverToRef } from '../accounts/resolvers/useAccountsMutationResolvers';\nimport { usePolkadotJsContext } from '../polkadotJs/usePolkadotJs'\nimport { gracefulExtensionCancelationErrorHandler, polkadotJsNotReadyYetError, reject, resolve, withGracefulErrors } from '../vesting/useVestingMutationResolvers';\nimport { TransferBalanceMutationVariables } from './useTransferBalanceMutation';\nimport { ExtrinsicStatus } from '@polkadot/types/interfaces/author';\nimport { DispatchError } from '@polkadot/types/interfaces/system';\nimport log from 'loglevel';\nimport { ApiPromise } from '@polkadot/api';\nimport { RuntimeDispatchInfo } from '@polkadot/types/interfaces/payment';\n\n// TODO: use validate JSON schema module of some sort\nexport const invalidTransferVariablesError = 'Invalid transfer parameters provided';\n\nexport const transferBalanceHandler = (\n    apiInstance: ApiPromise,\n    resolve: resolve, \n    reject: reject\n) => ({\n    status,\n    dispatchError\n}: {\n    status: ExtrinsicStatus,\n    dispatchError?: DispatchError\n}) => {\n    console.log('status', status);\n    if (status.isFinalized) log.info('operation finalized')\n\n    // TODO: handle status via the action log / notification stack\n    if (status.isInBlock) {\n        if (dispatchError?.isModule) {\n            return log.error('transfer unsuccessful', \n                apiInstance.registry.findMetaError(dispatchError.asModule)\n            );\n        }\n\n        return log.info('transfer successful');\n    }\n\n    // if the operation has been broadcast, finish the mutation\n    if (status.isBroadcast) {\n        log.info('transaction has been broadcast');\n        return resolve();\n    }\n    if (dispatchError) {\n        log.error('There was a dispatch error', \n            apiInstance.registry.findMetaError(dispatchError.asModule)\n        );\n        return reject();\n    }\n}\n\nexport const transferBalanceExtrinsic = (apiInstance: ApiPromise) => apiInstance.tx.currencies.transfer;\n\nexport const useEstimateTransferBalance = ({ from, to, currencyId, amount }: TransferBalanceMutationVariables) => {\n    const { apiInstance } = usePolkadotJsContext();\n    const [paymentInfo, setPaymentInfo] = useState<RuntimeDispatchInfo | undefined>(undefined);\n\n    const estimatePaymentInfo = useCallback(async () => {\n        if (!apiInstance || !from || !to || !currencyId || !amount) return setPaymentInfo(undefined);\n        \n        const paymentInfo = await transferBalanceExtrinsic(apiInstance)\n                .apply(apiInstance, [to, currencyId, amount])\n                .paymentInfo(from);\n        \n        setPaymentInfo(paymentInfo);\n\n    }, [apiInstance, from, to, currencyId, amount, setPaymentInfo]);\n\n    return { estimatePaymentInfo, paymentInfo };\n}\n\nexport const useBalanceMutationResolvers = () => {\n    const { apiInstance, loading } = usePolkadotJsContext();\n\n    const transferBalance = useResolverToRef(\n        useCallback(async (\n            _obj,\n            { from, to, currencyId, amount }: TransferBalanceMutationVariables\n        ) => {\n            if (!from || !to || !currencyId || !amount) throw new Error(invalidTransferVariablesError);\n            if (loading || !apiInstance) throw new Error(polkadotJsNotReadyYetError);\n\n            return withGracefulErrors(async (resolve, reject) => {\n                const { signer } = await web3FromAddress(from);\n                await transferBalanceExtrinsic(apiInstance).apply(apiInstance, [to, currencyId, amount])\n                    .signAndSend(\n                        from,\n                        { signer },\n                        transferBalanceHandler(apiInstance, resolve, reject)\n                    )\n            }, [\n                gracefulExtensionCancelationErrorHandler\n            ]);\n        }, [apiInstance, loading])\n    )\n\n    return {\n        transferBalance\n    }\n}","import { web3Enable } from '@polkadot/extension-dapp';\nimport { useCallback } from 'react'\nimport { useResolverToRef } from '../accounts/resolvers/useAccountsMutationResolvers'\n\nexport const __typename = 'Extension';\nexport const id = __typename;\nexport const useExtensionQueryResolvers = () => {\n    /**\n     * TODO: handle the followingc cases gracefully:\n     * - pending authorization request exists\n     * - user rejects the connection in the extension\n     * - app tries to connect again, after the connection has been rejected\n     */\n    const extension = useResolverToRef(\n        useCallback(async () => {\n            const extensions = await web3Enable('basilisk-ui');\n            return {\n                __typename,\n                id,\n                isAvailable: !!extensions.length,\n            };\n        }, [])\n    )\n\n    return {\n        extension\n    }\n}","import { ApolloCache, NormalizedCacheObject } from '@apollo/client';\nimport { useCallback } from 'react'\nimport { useResolverToRef } from '../accounts/resolvers/useAccountsMutationResolvers'\nimport { GetActiveAccountQueryResponse, GET_ACTIVE_ACCOUNT } from '../accounts/queries/useGetActiveAccountQuery';\nimport { usePolkadotJsContext } from '../polkadotJs/usePolkadotJs';\nimport { usePersistentConfig } from './usePersistentConfig';\n\nexport const accountCurrencyMapDataType = 'Option<u32>';\n\nexport const __typename = 'Config';\nexport const id = __typename;\n\nexport const nativeAssetId = '0';\n\nexport const useConfigQueryResolvers = () => {\n    const [persistedConfig] = usePersistentConfig();\n    const { apiInstance, loading } = usePolkadotJsContext();\n\n    const config = useResolverToRef(\n        useCallback(async (\n            _obj,\n            _variables,\n            { cache }: { cache: ApolloCache<NormalizedCacheObject> }\n        ) => {\n            if (!apiInstance || loading) return;\n\n            // TODO: evict config from the cache after active account changes\n            const address = cache.readQuery<GetActiveAccountQueryResponse>({\n                query: GET_ACTIVE_ACCOUNT\n            })?.account?.id;\n\n            let feePaymentAsset =  address\n                ? apiInstance.createType(\n                    accountCurrencyMapDataType,\n                    await apiInstance.query.multiTransactionPayment.accountCurrencyMap(address)\n                )?.toHuman()\n                : null\n\n            feePaymentAsset = feePaymentAsset ? feePaymentAsset : nativeAssetId\n            \n            return {\n                __typename,\n                id,\n                ...persistedConfig,\n                feePaymentAsset\n            };\n        }, [apiInstance, loading])\n    );\n\n    return {\n        config\n    }\n}","import { ApolloCache, NormalizedCacheObject } from '@apollo/client';\nimport { web3FromAddress } from '@polkadot/extension-dapp';\nimport { useCallback } from 'react'\nimport { useResolverToRef } from '../accounts/resolvers/useAccountsMutationResolvers'\nimport { GetActiveAccountQueryResponse, GET_ACTIVE_ACCOUNT } from '../accounts/queries/useGetActiveAccountQuery';\nimport { usePolkadotJsContext } from '../polkadotJs/usePolkadotJs';\nimport { gracefulExtensionCancelationErrorHandler, reject, resolve, vestingClaimHandler, withGracefulErrors } from '../vesting/useVestingMutationResolvers';\nimport { defaultConfigValue, usePersistentConfig } from './usePersistentConfig';\nimport { SetConfigMutationVariables } from './useSetConfigMutation';\n\nexport const defaultAssetId = '0';\n\nexport const setCurrencyHandler = (resolve: resolve, reject: reject) => {\n    return vestingClaimHandler(resolve, reject);\n}\n\nexport const useConfigMutationResolvers = () => {\n    const { apiInstance, loading } = usePolkadotJsContext();\n    const [_persistedConfig, setPersistedConfig] = usePersistentConfig();\n\n    const setConfig = useResolverToRef(\n        useCallback(async (\n            _obj,\n            args: SetConfigMutationVariables,\n            { cache }: { cache: ApolloCache<NormalizedCacheObject> }\n        ) => {\n            // TODO: error handling?\n            if (!apiInstance || loading) return;\n\n            // TODO: return an optimistic update to the cache with the new config\n            await withGracefulErrors(async (resolve, reject) => {\n                const address = cache.readQuery<GetActiveAccountQueryResponse>({\n                    query: GET_ACTIVE_ACCOUNT\n                })?.account?.id;\n\n                if (!address) return resolve();\n\n                const { signer } = await web3FromAddress(address);\n                \n                await apiInstance.tx.multiTransactionPayment.setCurrency(\n                    args.config?.feePaymentAsset || defaultAssetId\n                )\n                    .signAndSend(\n                        address,\n                        { signer },\n                        setCurrencyHandler(resolve, reject)\n                    )\n            }, [\n                gracefulExtensionCancelationErrorHandler\n            ]);\n            \n            const persistableConfig = args.config;\n            // there's no point in persisting the feePaymentAsset since it will\n            // be refetched from the node anyways\n            delete persistableConfig?.feePaymentAsset;\n            \n            setPersistedConfig(() => persistableConfig || defaultConfigValue);\n        }, [apiInstance, loading])\n    );\n\n    return {\n        setConfig\n    }\n}","import { useCallback } from 'react'\nimport { FeePaymentAsset } from '../../generated/graphql';\nimport { useResolverToRef } from '../accounts/resolvers/useAccountsMutationResolvers'\nimport { usePolkadotJsContext } from '../polkadotJs/usePolkadotJs';\n\nexport const __typename: FeePaymentAsset['__typename'] = 'FeePaymentAsset';\nexport const useFeePaymentAssetsQueryResolvers = () => {\n    const { apiInstance, loading } = usePolkadotJsContext();\n    const feePaymentAssets = useResolverToRef(\n        useCallback(async () => {\n            if (!apiInstance || loading) return;\n\n            const acceptedCurrencies = await apiInstance.query.multiTransactionPayment.acceptedCurrencies.entries()\n            const feePaymentAssets: FeePaymentAsset[] = acceptedCurrencies.map((acceptedCurrency) => {\n                const assetId = (acceptedCurrency[0].toHuman() as string[])[0];\n                return {\n                    // TODO: is there a safer type way to do this?\n                    // TODO: maybe? combine this with known asset data\n                    __typename,\n                    id: assetId,\n                    assetId: assetId,\n                    fallbackPrice: acceptedCurrency[1].toString()\n                }\n            })\n            \n            return feePaymentAssets;\n        }, [apiInstance, loading])\n    );\n\n    return {\n        feePaymentAssets\n    }\n}","import { useMemo } from 'react';\nimport { ApolloClient, createHttpLink, from, InMemoryCache, Resolvers,  } from '@apollo/client';\nimport { useAccountsQueryResolvers } from '../accounts/resolvers/useAccountsQueryResolvers';\nimport { loader } from 'graphql.macro';\nimport { useAccountsMutationResolvers } from '../accounts/resolvers/useAccountsMutationResolvers';\nimport { useRefetchWithNewBlock } from '../lastBlock/useRefetchWithNewBlock';\nimport { usePersistentConfig } from '../config/usePersistentConfig';\nimport { useVestingMutationResolvers } from '../vesting/useVestingMutationResolvers';\n\nimport { useBalanceMutationResolvers } from '../balances/useBalanceMutationResolvers';\nimport { useExtensionQueryResolvers } from '../polkadotJs/useExtensionQueryResolvers';\nimport { useConfigQueryResolvers } from '../config/useConfigQueryResolvers';\nimport { useConfigMutationResolvers } from '../config/useConfigMutationResolver';\nimport { useFeePaymentAssetsQueryResolvers } from '../feePaymentAssets/useFeePaymentAssetsQueryResolvers';\n\n/**\n * Add all local gql resolvers here\n * @returns Resolvers\n */\nexport const useResolvers: () => Resolvers = () => {\n    const { Query: AccountsQueryResolver, Account } = useAccountsQueryResolvers();\n    return {\n        Query: {\n            ...AccountsQueryResolver,\n            ...useExtensionQueryResolvers(),\n            ...useConfigQueryResolvers(),\n            ...useFeePaymentAssetsQueryResolvers(),\n        },\n        Mutation: {\n            ...useAccountsMutationResolvers(),\n            ...useVestingMutationResolvers(),\n            ...useBalanceMutationResolvers(),\n            ...useConfigMutationResolvers()\n        },\n        Account\n    }\n};\n\nexport const typeDefs = loader('./../../schema.graphql');\n\n/**\n * Recreates the apollo client instance each time the config changes\n * @returns \n */\nexport const useConfigureApolloClient = () => {\n    const resolvers = useResolvers();\n    const cache =  new InMemoryCache();\n    // can't get the config from a query before we setup apollo\n    // therefore we get it from the local storage instead\n    const [{ processorUrl }] = usePersistentConfig();\n\n    const client = useMemo(() => {\n        return new ApolloClient({\n            uri: processorUrl,\n            cache,\n            // TODO: don't connect in production\n            connectToDevTools: true,\n            queryDeduplication: true,\n            resolvers,\n            typeDefs,\n        })\n    }, [processorUrl]);\n    \n    useRefetchWithNewBlock(client);\n    \n    return client;\n};\n\nexport const useApollo = () => useConfigureApolloClient();","import { Resolver } from '@apollo/client';\nimport { useCallback } from 'react';\nimport { useBalanceQueryResolvers } from '../../balances/useBalanceQueryResolvers';\nimport { useResolverToRef } from './useAccountsMutationResolvers';\nimport { useVestingScheduleQueryResolvers } from '../../vesting/useVestingScheduleQueryResolvers';\nimport { useGetAccountsResolver } from './useGetAccountsQueryResolver';\n\n/**\n * Used to resolve queries for the `Account` (or `accounts`) entity.\n */\nexport const useAccountsQueryResolvers = () => {    \n    const getAccountsResolver = useGetAccountsResolver();\n\n    return {\n        Query: {\n            accounts: getAccountsResolver\n        },\n        /**\n         * Additional sub-resolvers for the `Account` entity,\n         * resolving e.g. the `balances` or `vestingSchedules` fields.\n         */\n        Account: {\n            ...useBalanceQueryResolvers(),\n            ...useVestingScheduleQueryResolvers()\n        }\n    }\n}","import { useLazyQuery, useQuery } from '@apollo/client';\nimport constate from 'constate';\nimport { loader } from 'graphql.macro';\nimport { Query } from '../../generated/graphql';\n\nexport const GET_EXTENSION = loader('./graphql/GetExtension.query.graphql');\n\nexport interface GetExtensionQueryResponse {\n    extension: Query['extension']\n}\n\nexport const useGetExtensionQuery = () => useQuery<GetExtensionQueryResponse>(GET_EXTENSION, {\n    notifyOnNetworkStatusChange: true,\n});\n\nexport const useGetExtensionLazyQuery = () => useLazyQuery<GetExtensionQueryResponse>(GET_EXTENSION, {\n    notifyOnNetworkStatusChange: true\n})\n\nexport const [GetExtensionQueryProvider, useContextualGetExtensionLazyQuery] = constate(useGetExtensionLazyQuery);","import { ApolloProvider, useApolloClient } from '@apollo/client';\nimport React from 'react';\nimport { GetActiveAccountQueryProvider } from '../hooks/accounts/queries/useGetActiveAccountQuery';\nimport { useConfigureApolloClient } from '../hooks/apollo/useApollo';\nimport { LastBlockNumberProvider } from '../hooks/lastBlock/useSubscribeNewBlockNumber';\nimport { GetExtensionQueryProvider } from '../hooks/polkadotJs/useGetExtensionQuery';\nimport { PolkadotJsProvider } from '../hooks/polkadotJs/usePolkadotJs';\n\nexport const ConfiguredApolloProvider = ({ children }: { children: React.ReactNode }) => {\n    const client = useConfigureApolloClient();\n    return (\n        <ApolloProvider client={client}>\n            {children}\n        </ApolloProvider>\n    )\n}\n\nexport const QueryProvider = ({ children }: { children: React.ReactNode }) => (\n    <GetExtensionQueryProvider>\n        {children}\n    </GetExtensionQueryProvider>\n)\n\n// TODO: use react-multi-provider instead of ugly nesting\nexport const MultiProvider = ({ children }: { children: React.ReactNode }) => {\n    return (\n        <PolkadotJsProvider>\n            <LastBlockNumberProvider>\n                <ConfiguredApolloProvider>\n                    <QueryProvider>\n                        {children}\n                    </QueryProvider>\n                </ConfiguredApolloProvider>\n            </LastBlockNumberProvider>\n        </PolkadotJsProvider>\n\n    )\n}","import { useMutation } from '@apollo/client';\nimport { loader } from 'graphql.macro';\nimport { GET_ACTIVE_ACCOUNT } from '../queries/useGetActiveAccountQuery';\n\nexport const SET_ACTIVE_ACCOUNT = loader('./../graphql/SetActiveAccount.mutation.graphql');\n\nexport interface SetActiveAccountMutationVariables {\n    id: string | undefined\n}\n\nexport const useSetActiveAccountMutation = (variables: SetActiveAccountMutationVariables) => useMutation<void, SetActiveAccountMutationVariables>(\n    SET_ACTIVE_ACCOUNT,\n    {\n        variables,\n        refetchQueries: [\n            GET_ACTIVE_ACCOUNT\n        ]\n    }\n)","import { useMutation } from '@apollo/client';\nimport { loader } from 'graphql.macro';\n\nexport const CLAIM_VESTED_AMOUNT = loader('./graphql/ClaimVestedAmount.mutation.graphql');\n\nexport type ClaimVestedAmountMutationResponse = void;\nexport interface ClaimVestedAmountMutationVariables {\n    address?: string\n}\n\n// no need to refetch queries, active account will refetch with every new block anyways\nexport const useClaimVestedAmountMutation = (variables?: ClaimVestedAmountMutationVariables) => useMutation<ClaimVestedAmountMutationResponse, ClaimVestedAmountMutationVariables>(\n    CLAIM_VESTED_AMOUNT,\n    { \n        variables,\n        notifyOnNetworkStatusChange: true,\n    }\n)","import { useMutation } from '@apollo/client';\nimport { loader } from 'graphql.macro';\n\nexport const TRANSFER_BALANCE = loader('./graphql/TransferBalance.mutation.graphql');\n\nexport interface TransferBalanceMutationVariables {\n    from?: string,\n    to?: string,\n    currencyId?: string,\n    amount?: string\n}\n\nexport const useTransferBalanceMutation = (variables: TransferBalanceMutationVariables) => useMutation<void, TransferBalanceMutationVariables>(\n    TRANSFER_BALANCE,\n    {\n        variables,\n    }\n)","import './App.scss';\nimport { MultiProvider } from './containers/MultiProvider';\nimport { Account, LastBlock, Maybe } from './generated/graphql';\nimport { useGetAccountsQuery } from './hooks/accounts/queries/useGetAccountsQuery';\nimport { useGetActiveAccountQuery } from './hooks/accounts/queries/useGetActiveAccountQuery';\nimport { useSetActiveAccountMutation } from './hooks/accounts/mutations/useSetActiveAccountMutation';\nimport { usePolkadotJsContext } from './hooks/polkadotJs/usePolkadotJs';\nimport { useLastBlockQuery } from './hooks/lastBlock/useLastBlockQuery';\nimport { useClaimVestedAmountMutation } from './hooks/vesting/useClaimVestedAmountMutation';\nimport log from 'loglevel';\nimport { useTransferBalanceMutation } from './hooks/balances/useTransferBalanceMutation';\nimport { useEstimateTransferBalance } from './hooks/balances/useBalanceMutationResolvers';\nimport { useCallback, useEffect, useMemo } from 'react';\nimport { useContextualGetExtensionLazyQuery } from './hooks/polkadotJs/useGetExtensionQuery';\nimport { useGetConfigQuery } from './hooks/config/useGetConfigQuery';\nimport { usePrevious } from 'react-use';\nimport { isEqual } from 'lodash';\nimport { useSetConfigMutation } from './hooks/config/useSetConfigMutation';\nimport { useGetFeePaymentAssetsQuery } from './hooks/feePaymentAssets/useGetFeePaymentAssetsQuery';\n\nlog.setLevel('info');\n\nexport const AccountDisplay = ({ account, lastBlock }: { account?: Maybe<Account> | undefined, lastBlock: Maybe<LastBlock> | undefined}) => {\n  const [setActiveAccount] = useSetActiveAccountMutation({ id: account?.id })\n  const [claimVestedAmount, { loading: claimLoading, error: claimError }] = useClaimVestedAmountMutation();\n  const transferBalanceVariables = {\n    from: account?.id,\n    to: 'bXi1Xh8UZvKUFCezgut35kv7U7ss3mK2BnEj3rdEen1tkaSoy',\n    currencyId: '0',\n    amount: '123456'\n  };\n  const [transferBalance, { loading: transferLoading, error: errorLoading }] = useTransferBalanceMutation(transferBalanceVariables);\n  const { paymentInfo, estimatePaymentInfo } = useEstimateTransferBalance(transferBalanceVariables);\n\n  useEffect(() => {\n    estimatePaymentInfo();\n  }, [lastBlock?.number])\n\n  return <div>\n    <span>{account?.__typename}</span>\n    <p>Last block: {lastBlock?.number}</p>\n    <p>{account?.id}</p>\n    <p>{account?.name}</p>\n    <p>Claim loading: {claimLoading ? 'true' : 'false'}</p>\n    <button onClick={_ => claimVestedAmount()}>claim</button>\n    <button onClick={_ => transferBalance()}>transfer</button>\n    <p>Transfer estimate: {paymentInfo?.partialFee.toHuman()}</p>\n    <p>Active: {account?.isActive ? 'true' : 'false'}</p>\n\n\n    {account?.vestingSchedule\n      ? \n        <>\n          <p>Vesting schedule start: {account.vestingSchedule.start}</p>\n        </>\n      : <></>\n    }\n\n    <div>\n      <p>Balances:</p>\n      {account?.balances.map((balance, i) => (\n        <p key={i}>{balance.assetId}: {balance.balance}</p>\n      ))}\n    </div>\n    <button onClick={_ => setActiveAccount()}>Set active</button>\n    <p>-------</p>\n  </div>\n}\n\nexport const ActiveAccount = () => {\n  const { data, loading, refetch, networkStatus, error } = useGetActiveAccountQuery();\n\n  return <div className=\"active-account\">\n    <h4 className=\"active-account__heading\">Active</h4>\n    <p>Loading: {loading ? 'true' : 'false'}</p>\n    <p>Network status: {networkStatus}</p>\n    <button onClick={_ => refetch && refetch()}>refetch</button>\n    <AccountDisplay account={data?.account} lastBlock={data?.lastBlock} />\n  </div>\n}\n\nexport const Accounts = () => {\n  const { data, loading, refetch, networkStatus, error } = useGetAccountsQuery();\n  error && console.error(error);\n  return <>\n    <h4>Accounts</h4>\n    <p>Loading: {loading ? 'true' : 'false'}</p>\n    <p>Network status: {networkStatus}</p>\n    <button onClick={_ => refetch && refetch()}>refetch</button>\n    {/* <p>Error: {error}</p> */}\n    {data?.accounts?.map((account, i) => (\n      <div key={i}>\n        <AccountDisplay account={account} lastBlock={data.lastBlock} />\n      </div>\n    ))}\n  </>\n}\n\nexport const LastBlockDisplay = () => {\n  const { data, loading } = useLastBlockQuery();\n\n  return <div>\n    <h4>Last block</h4>\n    <p>Block: {data?.lastBlock?.number}</p>\n    <p>Loading: {loading ? 'true' : 'false'}</p>\n  </div>\n}\n\nexport const ExtensionConnector = () => {\n  const [getExtension, { data }] = useContextualGetExtensionLazyQuery();\n  return <button onClick={_ => getExtension()}>Connect extension</button>\n}\n\nexport const ConfigDisplay = () => {\n  const { data, error, refetch } = useGetConfigQuery();\n  const [setConfigMutation] = useSetConfigMutation();\n  const feePaymentAsset = data?.config?.feePaymentAsset === '0' ? '1' : '0'\n\n  const setConfig = useCallback(() => data?.config ? setConfigMutation({\n    variables: {\n      config: {\n        ...data.config,\n        feePaymentAsset\n      }\n    }\n  }): null, [data]);\n  \n  if (error) console.error(error);\n\n  return <div>\n    <p>App name: {data?.config?.appName}</p>\n    <p>Fee payment asset: {data?.config?.feePaymentAsset}</p>\n    <button onClick={_ => setConfig()}>set config</button>\n  </div>\n}\n\nexport const FeePaymentAssets = () => {\n  const { data, loading, error } = useGetFeePaymentAssetsQuery();\n\n  return <>\n    {data?.feePaymentAssets?.map((feePaymentAsset) => {\n      return <div key={feePaymentAsset.assetId}>\n        {feePaymentAsset.assetId} / {feePaymentAsset.fallbackPrice}\n      </div>\n    })}\n  </>\n}\n\nexport const Page = () => {\n  const { loading } = usePolkadotJsContext();\n\n  return <>\n    {loading\n      ? (\n        <p>Loading...</p>\n      )\n      : (<>\n        {/* <FeePaymentAssets /> */}\n        {/* <ExtensionConnector /> */}\n        {/* <ConfigDisplay /> */}\n        {/* <LastBlockDisplay /> */}\n        {/* <ActiveAccount /> */}\n        <Accounts />\n      </>)\n    }\n  </>\n}\n\nexport const App = () => {\n  return (\n    <MultiProvider>\n      <Page />\n    </MultiProvider>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport './index.scss';\n\nReactDOM.render(\n  // TODO: figure out a way to enable react strict mode\n  // without triggering duplicate graphql queries\n  // https://github.com/apollographql/react-apollo/issues/3906#issuecomment-636604835\n  // <React.StrictMode>\n    <App/>,\n  // </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}