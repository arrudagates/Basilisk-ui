"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0}),exports.isWeb3Injected=void 0,Object.defineProperty(exports,"unwrapBytes",{enumerable:!0,get:function(){return _wrapBytes.unwrapBytes}}),exports.web3Accounts=web3Accounts,exports.web3AccountsSubscribe=web3AccountsSubscribe,exports.web3Enable=web3Enable,exports.web3EnablePromise=void 0,exports.web3FromAddress=web3FromAddress,exports.web3FromSource=web3FromSource,exports.web3ListRpcProviders=web3ListRpcProviders,exports.web3UseRpcProvider=web3UseRpcProvider,Object.defineProperty(exports,"wrapBytes",{enumerable:!0,get:function(){return _wrapBytes.wrapBytes}});var _defineProperty2=_interopRequireDefault(require("@babel/runtime/helpers/defineProperty")),_util=require("@polkadot/util"),_utilCrypto=require("@polkadot/util-crypto"),_util2=require("./util.cjs"),_wrapBytes=require("./wrapBytes.cjs");function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,o)}return t}function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach((function(r){(0,_defineProperty2.default)(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}const win=window;function web3IsInjected(){return 0!==Object.keys(win.injectedWeb3).length}function throwError(e){throw new Error(`${e}: web3Enable(originName) needs to be called before ${e}`)}function mapAccounts(e,r,t){return r.map((({address:r,genesisHash:o,name:n,type:s})=>({address:42===r.length?r:(0,_utilCrypto.encodeAddress)((0,_utilCrypto.decodeAddress)(r),t),meta:{genesisHash:o,name:n,source:e},type:s})))}win.injectedWeb3=win.injectedWeb3||{};let isWeb3Injected=web3IsInjected();exports.isWeb3Injected=isWeb3Injected;let web3EnablePromise=null;function getWindowExtensions(e){return Promise.all(Object.entries(win.injectedWeb3).map((([r,{enable:t,version:o}])=>Promise.all([Promise.resolve({name:r,version:o}),t(e).catch((e=>{console.error(`Error initializing ${r}: ${e.message}`)}))]))))}function web3Enable(e,r=[]){if(!e)throw new Error("You must pass a name for your app to the web3Enable function");const t=r.length?Promise.all(r.map((e=>e().catch((()=>!1))))):Promise.resolve([!0]);return exports.web3EnablePromise=web3EnablePromise=(0,_util2.documentReadyPromise)((()=>t.then((()=>getWindowExtensions(e).then((e=>e.filter((e=>!!e[1])).map((([e,r])=>(r.accounts.subscribe||(r.accounts.subscribe=e=>(r.accounts.get().then(e).catch(console.error),()=>{})),_objectSpread(_objectSpread({},e),r)))))).catch((()=>[])).then((e=>{const r=e.map((({name:e,version:r})=>`${e}/${r}`));return exports.isWeb3Injected=isWeb3Injected=web3IsInjected(),console.log(`web3Enable: Enabled ${e.length} extension${1!==e.length?"s":""}: ${r.join(", ")}`),e})))))),web3EnablePromise}async function web3Accounts({accountType:e,ss58Format:r}={}){if(!web3EnablePromise)return throwError("web3Accounts");const t=[],o=await web3EnablePromise,n=await Promise.all(o.map((async({accounts:t,name:o})=>{try{return mapAccounts(o,(await t.get()).filter((({type:r})=>!r||!e||e.includes(r))),r)}catch(n){return[]}})));n.forEach((e=>{t.push(...e)}));const s=t.map((({address:e})=>e));return console.log(`web3Accounts: Found ${t.length} address${1!==t.length?"es":""}: ${s.join(", ")}`),t}async function web3AccountsSubscribe(e,{ss58Format:r}={}){if(!web3EnablePromise)return throwError("web3AccountsSubscribe");const t={},o=(await web3EnablePromise).map((({accounts:{subscribe:o},name:n})=>o((o=>{t[n]=o,e(Object.entries(t).reduce(((e,[t,o])=>(e.push(...mapAccounts(t,o,r)),e)),[]))}))));return()=>{o.forEach((e=>{e()}))}}async function web3FromSource(e){if(!web3EnablePromise)return throwError("web3FromSource");const r=await web3EnablePromise,t=e&&r.find((({name:r})=>r===e));if(!t)throw new Error(`web3FromSource: Unable to find an injected ${e}`);return t}async function web3FromAddress(e){if(!web3EnablePromise)return throwError("web3FromAddress");const r=await web3Accounts();let t;if(e){const o=(0,_utilCrypto.decodeAddress)(e);t=r.find((e=>(0,_util.u8aEq)((0,_utilCrypto.decodeAddress)(e.address),o)))}if(!t)throw new Error(`web3FromAddress: Unable to find injected ${e}`);return web3FromSource(t.meta.source)}async function web3ListRpcProviders(e){const{provider:r}=await web3FromSource(e);return r?r.listProviders():(console.warn(`Extension ${e} does not expose any provider`),null)}async function web3UseRpcProvider(e,r){const{provider:t}=await web3FromSource(e);if(!t)throw new Error(`Extension ${e} does not expose any provider`);return{meta:await t.startProvider(r),provider:t}}exports.web3EnablePromise=web3EnablePromise;