{"version":3,"sources":["hooks/accounts/queries/useGetAccountsQuery.tsx","hooks/accounts/usePersistActiveAccount.tsx","hooks/accounts/resolvers/useSetActiveAccountMutationResolver.tsx","hooks/accounts/useSetActiveAccount.tsx","hooks/accounts/resolvers/useAccountsMutationResolvers.tsx","hooks/polkadotJs/typesConfig.tsx","hooks/config/usePersistentConfig.tsx","hooks/polkadotJs/usePolkadotJs.tsx","hooks/balances/useGetBalancesByAddress.tsx","hooks/balances/useBalanceQueryResolvers.tsx","hooks/vesting/useGetVestingScheduleByAddress.tsx","hooks/vesting/useVestingScheduleQueryResolvers.tsx","hooks/accounts/useGetAccounts.tsx","hooks/accounts/resolvers/useGetAccountsQueryResolver.tsx","hooks/lastBlock/useLastBlockQuery.tsx","hooks/lastBlock/useSubscribeNewBlockNumber.tsx","hooks/lastBlock/useRefetchWithNewBlock.tsx","hooks/accounts/queries/useGetActiveAccountQuery.tsx","hooks/vesting/useVestingMutationResolvers.tsx","hooks/balances/useBalanceMutationResolvers.tsx","hooks/polkadotJs/useExtensionQueryResolvers.tsx","hooks/config/useConfigQueryResolvers.tsx","hooks/config/useConfigMutationResolver.tsx","hooks/feePaymentAssets/useFeePaymentAssetsQueryResolvers.tsx","hooks/math/useMath.tsx","hooks/pools/useGetXykPools.tsx","hooks/pools/lbp/calculateOppositeAssetWeight.tsx","hooks/pools/lbp/calculateCurrentAssetWeight.tsx","hooks/lastBlock/readLastBlock.tsx","hooks/pools/useGetLbpPools.tsx","hooks/pools/useGetLbpPool.tsx","hooks/pools/resolvers/useGetPoolsQueryResolver.tsx","hooks/pools/useGetXykPool.tsx","hooks/assets/resolvers/useGetAssetsQueryResolver.tsx","hooks/assets/useGetAssets.tsx","components/Chart/shared.tsx","generated/graphql.tsx","hooks/accounts/readActiveAccount.tsx","hooks/pools/lbp/buy.tsx","hooks/pools/lbp/sell.tsx","hooks/actionLog/queries/useGetActionLogQuery.tsx","hooks/actionLog/helpers/readActionLog.tsx","hooks/actionLog/helpers/readUserAction.tsx","hooks/actionLog/resolvers/useGetActionLogQueryResolver.tsx","hooks/actionLog/helpers/addAction.tsx","hooks/actionLog/helpers/updateUserAction.tsx","hooks/actionLog/handleTransactionStatus.tsx","hooks/pools/xyk/buy.tsx","hooks/pools/xyk/sell.tsx","hooks/pools/resolvers/usePoolsMutationResolvers.tsx","hooks/pools/resolvers/useSubmitTradeMutationResolvers.tsx","hooks/actionLog/useActionQueryResolvers.tsx","hooks/apollo/useApollo.tsx","hooks/accounts/resolvers/useAccountsQueryResolvers.tsx","hooks/pools/resolvers/usePoolsQueryResolver.tsx","hooks/assets/resolvers/useAssetsQueryResolvers.tsx","hooks/polkadotJs/useGetExtensionQuery.tsx","containers/MultiProvider.tsx","hooks/pools/queries/useGetPoolByAssetsQuery.tsx","components/Input/TokenInput.tsx","hooks/math/useFromPrecision.tsx","hooks/math/useToPrecision.tsx","containers/TradeForm/hooks/useTradeForm.tsx","containers/TradeForm/hooks/useListenForInput.tsx","hooks/pools/mutations/useSubmitTradeMutation.tsx","containers/TradeForm/hooks/useHandleSubmit.tsx","hooks/pools/xyk/calculateOutGivenIn.tsx","hooks/pools/lbp/calculateInGivenOut.tsx","hooks/pools/lbp/calculateOutGivenIn.tsx","hooks/pools/xyk/calculateInGivenOut.tsx","hooks/pools/poolHasAssets.tsx","hooks/math/usePercentageChange.tsx","containers/TradeForm/hooks/useSlippage.tsx","constants.tsx","containers/TradeForm/hooks/usePercentageFee.tsx","containers/TradeForm/hooks/useCalculateAllowedSlippage.tsx","containers/TradeForm/TradeForm.tsx","containers/TradeForm/hooks/useTradeType.tsx","containers/TradeForm/hooks/useHandleAssetIdsChange.tsx","containers/TradeForm/hooks/useCalculateInAndOut.tsx","containers/TradeForm/hooks/useResetAmountInputsOnPoolChange.tsx","containers/TradeChart.tsx","hooks/pools/lbp/calculateSpotPrice.tsx","hooks/pools/xyk/calculateSpotPrice.tsx","pages/TradePage/TradePage.tsx","pages/TradePage/hooks/useSpotPrice.tsx","hooks/accounts/mutations/useSetActiveAccountMutation.tsx","pages/WalletPage.tsx","hooks/actionLog/queries/useGetUserActionsQuery.tsx","hooks/actionLog/helpers/removeUserAction.tsx","pages/ActionLogPage.tsx","containers/Router.tsx","components/Navigation/ActionBar.tsx","components/Navigation/Navigation.tsx","containers/TopBar.tsx","containers/PageContainer.tsx","hooks/misc/useLoading.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["GET_ACCOUNTS","defaultValue","id","undefined","usePersistedActiveAccount","createPersistedState","usePersistActiveAccount","useSetActiveAccountMutationResolver","setActiveAccount","_persistedActiveAccount","setPersistedActiveAccount","useCallback","async","client","address","accountsData","cache","readQuery","query","accounts","map","account","isActive","activeAccount","find","forEach","modify","identify","__typename","fields","_","Promise","resolve","setTimeout","useSetActiveAccount","useResolverToRef","_obj","args","resolver","name","resolverRef","useRef","useEffect","current","log","debug","apply","arguments","defaultConfigValue","nodeUrl","process","processorUrl","appName","usePersistedConfig","usePersistentConfig","getPoolAccount","description","params","type","rpc","xyk","lbp","PolkadotJsProvider","usePolkadotJsContext","constate","apiInstance","setApiInstance","useState","loading","useMemo","provider","WsProvider","types","typesConfig","ormlTypes","typesAlias","ormlTypesAlias","api","ApiPromise","create","isReady","disconnect","nativeAssetId","useGetBalancesByAddress","assetIds","balances","includes","nativeAssetBalance","system","push","assetId","balance","data","free","toString","assetBalances","filter","e","tokens","multi","codec","i","entries","storageKey","toHuman","assetBalance","createType","getBalancesByAddress","useBalanceQueryResolvers","entity","assetInId","assetOutId","balanceLockDataType","getLockedBalanceByAddressAndLockId","lockId","lockedNativeBalance","locks","lockedAmount","eq","tokenBalanceLocks","_storageKey","tokenBalanceLock","toJSON","amount","lockedTokensBalance","useVestingScheduleQueryResolvers","getVestingScheduleByAddress","vestingSchedule","first","vesting","vestingSchedules","lockedVestingAmount","remainingVestingAmount","start","period","periodCount","perPeriod","useGetVestingScheduleByAddress","useGetAccountsQueryResolver","persistedActiveAccount","getAccounts","persistedActiveAccountId","web3Enable","web3Accounts","encodeAddress","decodeAddress","meta","isArray","GET_LAST_BLOCK","LastBlockProvider","useLastBlockContext","lastBlock","setLastBlock","subscribeNewBlocks","derive","chain","validationData","parachainSystem","validationDataOption","isSome","parachainBlockNumber","block","header","number","relaychainBlockNumber","writeLastBlock","writeQuery","GET_ACTIVE_ACCOUNT","useGetActiveAccountQuery","useApolloClient","result","useQuery","notifyOnNetworkStatusChange","refetchQueries","GetActiveAccountQueryProvider","useGetActiveAccountQueryContext","withGracefulErrors","fn","errorHandlers","reject","console","reduce","errorHandler","gracefulExtensionCancelationErrorHandler","message","error","vestingClaimHandler","status","events","dispatchError","isFinalized","info","event","method","section","phase","isInBlock","createdAtHash","isModule","registry","findMetaError","asModule","isBroadcast","hash","polkadotJsNotReadyYetError","useVestingMutationResolvers","claimVestedAmount","variables","Error","signer","web3FromAddress","tx","claim","signAndSend","transferBalanceExtrinsic","currencies","transfer","useBalanceMutationResolvers","transferBalance","from","to","currencyId","transferBalanceHandler","useConfigQueryResolvers","persistedConfig","config","_variables","feePaymentAsset","multiTransactionPayment","accountCurrencyMap","useConfigMutationResolvers","_persistedConfig","setPersistedConfig","setConfig","setCurrency","setCurrencyHandler","persistableConfig","useFeePaymentAssetsQueryResolvers","feePaymentAssets","acceptedCurrencies","acceptedCurrency","fallbackPrice","loadMath","MathProvider","useMathContext","wasm","setWasm","instance","math","mapToPoolId","hundredWithPrecision6","BigNumber","multipliedBy","pow","calculateOppositeAssetWeight","weight","minus","toFixed","calculateCurrentAssetWeight","pool","weights","calculate_linear_weights","startBlock","endBlock","initial","final","readLastBlock","repayFee","numerator","denominator","mapToPool","poolData","lastBlockData","feeCollector","repayTarget","partialPool","assets","end","partialAssetAWeights","initialWeight","finalWeight","assetAWeights","assetBWeights","feeCollectorBalanceLockAmount","repayTargetReached","gt","poolFee","fee","useGetLbpPools","all","getLbpPools","useGetLbpPool","poolId","getLbpPool","useGetPoolsQueryResolver","getXykPools","poolAssets","useGetXykPools","getXykPool","useGetXykPool","context","poolIds","lbpPoolId","xykPoolId","getPoolIdsByAssetIds","lbpPool","xykPool","lbpPools","xykPools","concat","useGetAssetsQueryResolver","getAssets","assetRegistry","mapToAsset","useGetAssets","asset","ChartGranularity","ChartType","PoolType","Status","TradeType","UserActionType","readActiveAccount","returnPartialData","buy","assetBuy","assetSell","amountBuy","maxSold","buyHandler","sell","amountSell","minBought","sellHandler","GET_ACTION_LOG","readActionLog","actionLog","readUserAction","actions","addAction","item","action","updateUserAction","inBlockHash","s","clientDetails","details","isOk","errorEvent","ExtrinsicFailed","is","errorInfo","reason","ExtrinsicSuccess","ex","handleTransactionStatus","txData","IsReady","blockHeight","IsBroadcast","isSuccess","errorReason","IsInBlock","asInBlock","toHex","IsError","IsFinalized","userAction","txSuccess","asFinalized","blockHash","signedBlock","getBlock","paraChainBlockHeight","txHash","txBlockIndex","findIndex","extrinsics","warn","txId","height","index","blockPart","String","padStart","indexPart","_hash","startsWith","substring","shortHash","length","padEnd","slice","formatId","newId","entry","evict","updateUserActionId","call","Buy","Unapproved","Sell","usePoolsMutationResolvers","submitTrade","poolType","XYK","tradeType","buyXyk","assetOutAmount","amountWithSlippage","sellXyk","assetInAmount","LBP","buyLbp","sellLbp","useSubmitTradeMutationResolver","useActionLogQueryResolvers","useResolvers","Query","AccountsQueryResolver","Account","PoolsQueryResolver","XYKPool","LBPPool","getPoolsQueryResolver","poolFieldsQueryResolvers","pools","usePoolsQueryResolver","extension","extensions","isAvailable","Mutation","typeDefs","useConfigureApolloClient","resolvers","inMemoryCache","InMemoryCache","persistCache","storage","LocalStorageWrapper","window","localStorage","then","ApolloClient","uri","connectToDevTools","queryDeduplication","updateCache","useRefetchWithNewBlock","GET_EXTENSION","useGetExtensionQuery","GetExtensionQueryProvider","useContextualGetExtensionLazyQuery","useLazyQuery","ConfiguredApolloProvider","children","ApolloProvider","QueryProvider","MultiProvider","GET_POOL_BY_ASSETS","TokenInput","assetIdInputProps","assetAmountInputProps","disabled","precision12","fromPrecision12","dividedBy","toPrecision12","useListenForInput","form","field","state","setState","inputRef","control","_fields","_f","ref","listener","addEventListener","removeEventListener","SUBMIT_TRADE","useHandleSubmit","allowedSlippage","slippage","useMutation","spotPriceAmount","slippageAmount","amountBN","plus","applyAllowedSlippage","calculateOutGivenInFromPool","amountIn","assetInBalance","assetOutBalance","inReserve","outReserve","calculate_out_given_in","calculateOutGivenIn","getPoolBalances","assetABalance","assetBBalance","getInAndOutWeights","assetInWeight","assetOutWeight","calculateInGivenOutFromPool","amountOut","inWeight","outWeight","calculate_in_given_out","calculateInGivenOut","poolHasAssets","percentageChange","a","b","aBN","calculateSlippage","spotPrice","resultPercentageChange","isNaN","ROUNDING_MODE","ROUND_UP","percentualSlippage","abs","useSlippage","aToB","bToA","xykFee","feeToPercentage","feeFromPool","constants","defaultAllowedSlippage","useCalculateAllowedSlippage","watchAutoSlippage","watch","allowedSlippageInputDisabled","getValues","allowedSlippageWithFee","setValue","TradeForm","onAssetIdsChange","useForm","defaultValues","autoSlippage","useTradeForm","usePercentageFee","setTradeType","watchassetInAmount","watchAassetInId","watchAassetOutAmount","watchAassetOutId","useTradeType","useHandleAssetIdsChange","calculateOutGivenInFromPoolXYK","calculateOutGivenInFromPoolLBP","calculateInGivenOutFromPoolXYK","calculateInGivenOutFromPoolLBP","outAmount","inAmount","useCalculateInAndOut","previousPoolId","usePreviousDistinct","isEqual","resetField","useResetAmountInputsOnPoolChange","handleSubmit","onSubmit","register","TradeChart","poolLiquidity","oneWithPrecision","calculateSpotPriceFromPool","get_spot_price","calculateSpotPrice","TradePage","setAssetIds","poolLoading","poolError","calculateSpotPriceFromPoolXYK","calculateSpotPriceFromPoolLBP","useSpotPrice","newIds","SET_ACTIVE_ACCOUNT","useSetActiveAccountMutation","unsetActiveAccount","style","marginBottom","padding","paddingLeft","onClick","WalletPage","accountsLoading","extensionData","extensionLoading","textAlign","GET_USER_ACTIONS","useGetUserActions","pollInterval","userActions","value","ActionLogPage","clientActionLogData","clientLoading","actionLogData","cachedData","d","cloneDeep","unshift","Router","path","element","ActionBar","activeAccountLoading","accountData","isExtensionAvailable","className","Navigation","TopBar","activeAccountData","PageContainer","useLoading","width","margin","setLevel","branch","baseName","App","basename","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.e06a415c.chunk.js","sourcesContent":["import { useQuery } from '@apollo/client'\nimport { Query } from '../../../generated/graphql';\nimport { loader } from 'graphql.macro';\n\nexport const GET_ACCOUNTS = loader('./../graphql/GetAccounts.query.graphql');\nexport interface GetAccountsQueryResponse {\n    accounts: Query['accounts'],\n    lastBlock: Query['lastBlock']\n}\n\nexport const useGetAccountsQuery = () => useQuery<GetAccountsQueryResponse>(GET_ACCOUNTS, {\n    notifyOnNetworkStatusChange: true,\n});","import { useLocalStorage } from 'react-use';\nimport { Account } from '../../generated/graphql';\nimport createPersistedState from 'use-persisted-state';\n\nexport const key = 'basilisk-active-account';\nexport const defaultValue = {\n    id: undefined\n};\nexport interface PersistedAccount {\n    id: string | undefined\n}\n\n// we're not using react-use/useLocalStorage since i couldn't figure out\n// why it would not trigger effects when the local storage updates\nconst usePersistedActiveAccount = createPersistedState(key);\nexport const usePersistActiveAccount = () => usePersistedActiveAccount<PersistedAccount | undefined>(defaultValue);","import { ApolloCache, ApolloClient, NormalizedCacheObject } from '@apollo/client';\nimport { useCallback } from 'react';\nimport { useSetActiveAccount } from '../useSetActiveAccount'\nimport { SetActiveAccountMutationVariables } from '../mutations/useSetActiveAccountMutation';\nimport { useResolverToRef } from './useAccountsMutationResolvers';\n\nexport const useSetActiveAccountMutationResolver = () => {\n    const setActiveAccount = useSetActiveAccount();\n    \n    return useResolverToRef(\n        useCallback(async (\n            _obj,\n            args: SetActiveAccountMutationVariables,\n            { client }: { client: ApolloClient<NormalizedCacheObject> }\n        ) => setActiveAccount(client, args.id), [setActiveAccount]),\n        'setActiveAccount'\n    )\n}","import { ApolloCache, ApolloClient, NormalizedCacheObject, useApolloClient } from '@apollo/client';\nimport { gql } from 'graphql.macro';\nimport { find } from 'lodash';\nimport { useCallback } from 'react';\nimport { GetAccountsQueryResponse, GET_ACCOUNTS } from './queries/useGetAccountsQuery';\nimport { usePersistActiveAccount } from './usePersistActiveAccount';\n\nexport const useSetActiveAccount = () => {\n    const [_persistedActiveAccount, setPersistedActiveAccount] = usePersistActiveAccount();\n\n    return useCallback(async (\n        client: ApolloClient<NormalizedCacheObject>,\n        address: string | undefined\n    ) => {\n        const accountsData = client.cache?.readQuery<GetAccountsQueryResponse>({\n            query: GET_ACCOUNTS,\n        });\n\n        if (!accountsData?.accounts) return;\n\n        const accounts = accountsData.accounts\n            .map(account => ({\n                ...account,\n                isActive: account.id === address ? true : false\n            }))\n        \n        const activeAccount = find(accounts, { isActive: true });\n        setPersistedActiveAccount({\n            id: activeAccount?.id\n        })\n        \n        // TODO: return the data to be mutated from the mutation instead\n        // client.cache?.writeQuery<GetAccountsQueryResponse>({\n        //     query: GET_ACCOUNTS,\n        //     data: { accounts, lastBlock: accountsData.lastBlock }\n        // });\n\n        accounts.forEach(account => {\n            client.cache.modify({\n                id: client.cache.identify({\n                    __typename: account.__typename,\n                    id: account.id\n                }),\n                fields: {\n                    isActive: _ => account.isActive\n                }\n            })\n        });\n\n        // wait for the local storage changes before finishing the mutation\n        // TODO: find a better way to wait until the local storage changes are\n        // propagated to the resolverRef\n        await (new Promise(resolve => setTimeout(resolve, 0)));\n\n        return accounts;\n    }, [ \n        setPersistedActiveAccount\n    ])\n}","import { ApolloCache, ApolloClient, NormalizedCacheObject, Resolver } from '@apollo/client'\nimport { find } from 'lodash';\nimport { useCallback, useEffect, useRef } from 'react';\nimport { SetActiveAccountMutationVariables } from '../mutations/useSetActiveAccountMutation'\nimport log from 'loglevel';\nimport { useSetActiveAccount } from '../useSetActiveAccount';\nimport { useSetActiveAccountMutationResolver } from './useSetActiveAccountMutationResolver';\n\n/**\n * Updates the resolver fn ref each time the given resolver fn changes.\n * \n * This is necessary to reflect changes made to functions within hooks\n * within the Apollo resolvers configuration. \n */\nexport const useResolverToRef = (resolver: Resolver, name?: string) => {\n    const resolverRef = useRef(resolver);\n    // when the resolver changes, update the ref\n    useEffect(() => { resolverRef.current = resolver }, [resolver]);\n\n    return function resolverFromRef() {\n        // TODO is there a better way to debug resolvers? Since the function name\n        // is not visible in the apollo error\n        log.debug('Running resolver', name);\n        // execute the wrapper resolver ref, with the given arguments from Apollo\n        return resolverRef.current.apply(undefined, arguments as any);\n    }\n}\n\n/**\n * Used to resolve mutations regarding the Account entity\n * @returns \n */\nexport const useAccountsMutationResolvers = () => {\n    const setActiveAccountMutationResolver = useSetActiveAccountMutationResolver();\n\n    return {\n        setActiveAccount: setActiveAccountMutationResolver\n    }\n}","export default {\n    \"alias\": {\n      \"tokens\": {\n        \"AccountData\": \"OrmlAccountData\"\n      }\n    },\n    \"types\": [\n      {\n        \"AssetPair\": {\n          \"asset_in\": \"AssetId\",\n          \"asset_out\": \"AssetId\"\n        },\n        \"Amount\": \"i128\",\n        \"AmountOf\": \"Amount\",\n        \"Address\": \"AccountId\",\n        \"OrmlAccountData\": {\n          \"free\": \"Balance\",\n          \"frozen\": \"Balance\",\n          \"reserved\": \"Balance\"\n        },\n        \"Fee\": {\n          \"numerator\": \"u32\",\n          \"denominator\": \"u32\"\n        },\n        \"BalanceInfo\": {\n          \"amount\": \"Balance\",\n          \"assetId\": \"AssetId\"\n        },\n        \"Chain\": {\n          \"genesisHash\": \"Vec<u8>\",\n          \"lastBlockHash\": \"Vec<u8>\"\n        },\n        \"Currency\": \"AssetId\",\n        \"CurrencyId\": \"AssetId\",\n        \"CurrencyIdOf\": \"AssetId\",\n        \"Intention\": {\n          \"who\": \"AccountId\",\n          \"asset_sell\": \"AssetId\",\n          \"asset_buy\": \"AssetId\",\n          \"amount\": \"Balance\",\n          \"discount\": \"bool\",\n          \"sell_or_buy\": \"IntentionType\"\n        },\n        \"IntentionId\": \"Hash\",\n        \"IntentionType\": {\n          \"_enum\": [\n            \"SELL\",\n            \"BUY\"\n          ]\n        },\n        \"LookupSource\": \"AccountId\",\n        \"Price\": \"Balance\",\n        \"ClassId\": \"u64\",\n        \"TokenId\": \"u64\",\n        \"ClassData\": {\n          \"is_pool\": \"bool\"\n        },\n        \"TokenData\": {\n          \"locked\": \"bool\"\n        },\n        \"ClassInfo\": {\n          \"metadata\": \"Vec<u8>\",\n          \"total_issuance\": \"TokenId\",\n          \"owner\": \"AccountId\",\n          \"data\": \"ClassData\"\n        },\n        \"TokenInfo\": {\n          \"metadata\": \"Vec<u8>\",\n          \"owner\": \"AccountId\",\n          \"data\": \"TokenData\"\n        },\n        \"ClassInfoOf\": \"ClassInfo\",\n        \"TokenInfoOf\": \"TokenInfo\",\n        \"ClassIdOf\": \"ClassId\",\n        \"TokenIdOf\": \"TokenId\",\n        \"OrderedSet\": \"Vec<AssetId>\",\n        \"VestingSchedule\": {\n          \"start\": \"BlockNumber\",\n          \"period\": \"BlockNumber\",\n          \"period_count\": \"u32\",\n          \"per_period\": \"Compact<Balance>\"\n        },\n        \"VestingScheduleOf\": \"VestingSchedule\",\n        \"LBPWeight\": \"u32\",\n        \"WeightCurveType\": {\n          \"_enum\": [\n            \"Linear\"\n          ]\n        },\n        \"PoolId\": \"AccountId\",\n        \"BalanceOf\": \"Balance\",\n        \"AssetType\": {\n          \"_enum\": {\n            \"Token\": \"Null\",\n            \"PoolShare\": \"(AssetId,AssetId)\"\n          }\n        },\n        \"Pool\": {\n          \"owner\": \"AccountId\",\n          \"start\": \"BlockNumber\",\n          \"end\": \"BlockNumber\",\n          \"assets\": \"AssetPair\",\n          \"initial_weight\": \"LBPWeight\",\n          \"final_weight\": \"LBPWeight\",\n          \"weight_curve\": \"WeightCurveType\",\n          \"fee\": \"Fee\",\n          \"fee_collector\": \"AccountId\"\n        },\n        \"AssetDetails\": {\n          \"name\": \"Vec<u8>\",\n          \"asset_type\": \"AssetType\",\n          \"existential_deposit\": \"Balance\",\n          \"locked\": \"bool\"\n        },\n        \"AssetDetailsT\": \"AssetDetails\",\n        \"AssetMetadata\": {\n          \"symbol\": \"Vec<u8>\",\n          \"decimals\": \"u8\"\n        },\n        \"AssetInstance\": \"AssetInstanceV1\",\n        \"MultiLocation\": \"MultiLocationV1\",\n        \"AssetNativeLocation\": \"MultiLocation\",\n        \"MultiAsset\": \"MultiAssetV1\",\n        \"Xcm\": \"XcmV1\",\n        \"XcmOrder\": \"XcmOrderV1\"\n      }\n    ]\n  };","import createPersistedState from 'use-persisted-state';\nimport { Config } from '../../generated/graphql';\n\nconst key = 'basilisk-config';\nexport const defaultConfigValue = {\n    nodeUrl: process.env.REACT_APP_NODE_URL!,\n    processorUrl: process.env.REACT_APP_PROCESSOR_URL!,\n    appName: process.env.REACT_APP_APP_NAME!\n};\n\n// TODO: write apollo integration for querying and mutating the config\nconst usePersistedConfig = createPersistedState(key)\nexport const usePersistentConfig = () => usePersistedConfig<Config>(defaultConfigValue);","import { ApiPromise, WsProvider, HttpProvider } from '@polkadot/api';\nimport { ProviderInterface } from '@polkadot/rpc-provider/types'\nimport { useMemo, useState, useEffect } from 'react';\nimport constate from 'constate';\nimport typesConfig from './typesConfig';\nimport { usePersistentConfig } from '../config/usePersistentConfig';\nimport { types as ormlTypes, typesAlias as ormlTypesAlias } from '@open-web3/orml-type-definitions'\n\nconst getPoolAccount = {\n  description: 'Get pool account id by asset IDs',\n  params: [\n    {\n      name: 'assetInId',\n      type: 'u32'\n    },\n    {\n      name: 'assetOutId',\n      type: 'u32'\n    }\n  ],\n  type: 'AccountId'\n};\nconst rpc = {\n  xyk: {\n    getPoolAccount  \n  },\n  lbp: {\n    getPoolAccount\n  }\n}\n\n/**\n * Setup an instance of PolkadotJs, and watch\n * for config updates. In case the nodeUrl changes,\n * then re-create the PolkadotJs instance\n */\nexport const useConfigurePolkadotJs = () => {\n  const [{ nodeUrl }] = usePersistentConfig();\n  const [apiInstance, setApiInstance] = useState<ApiPromise | undefined>(undefined);\n  const loading = useMemo(() => apiInstance ? false : true, [apiInstance]);\n  const provider = useMemo(() => new WsProvider(nodeUrl), [nodeUrl]);\n\n  const types = useMemo(() => ({\n    ...typesConfig.types[0],\n    ...ormlTypes,\n  }), []);\n\n  const typesAlias = useMemo(() => ({\n    ...typesConfig.alias,\n    ...ormlTypesAlias\n  }), []);\n\n  // (re-)Create the PolkadotJS instance, when the provider updates.\n  useEffect(() => {\n    (async () => {\n      setApiInstance(undefined);\n      const api = await ApiPromise.create({\n        provider,\n        types,\n        typesAlias,\n        rpc\n      });\n      await api.isReady;\n      setApiInstance(api);\n    })();\n\n    // when the component using the usePolkadot hook unmounts, disconnect the websocket\n    return () => {\n      apiInstance?.disconnect();\n    };\n  }, [provider]);\n\n  return { apiInstance, loading };\n};\n\n// TODO: lift to context using constate\n// export const usePolkadotJs = () => useConfigurePolkadotJs();\nexport const [PolkadotJsProvider, usePolkadotJsContext] = constate(useConfigurePolkadotJs);","import { ApiPromise } from '@polkadot/api';\nimport { includes } from 'lodash';\nimport { useCallback } from 'react';\nimport { Balance } from '../../generated/graphql';\nimport { usePolkadotJsContext } from '../polkadotJs/usePolkadotJs';\n\nexport const nativeAssetId = '0';\nexport const assetBalanceDataType = 'AccountData';\n\nexport const getBalancesByAddress = async (\n    apiInstance: ApiPromise, \n    address: string, \n    assetIds?: string[]\n) => {\n    const balances: Balance[] = [];\n        \n    // fetch the native balance, only if no assetIds were specified, or if it was explicitly requested\n    if (!assetIds || includes(assetIds, nativeAssetId)) {\n        const nativeAssetBalance = await apiInstance.query.system.account(address);    \n\n        balances.push({\n            assetId: nativeAssetId,\n            balance: nativeAssetBalance?.data.free.toString()\n        });\n    }\n\n    // we've already fetched the native balance above, ignore it down the line\n    assetIds = assetIds ? assetIds.filter(e => e !== nativeAssetId) : assetIds;\n\n    // TODO: write type definitions for `query.tokens`\n    const assetBalances = assetIds\n        // if there are specific assetIds to fetch, query only those\n        ? (await apiInstance.query.tokens.accounts.multi(\n            // query for [address, assetId]\n            assetIds\n                ?.map((assetId) => [address, assetId])\n        ))\n            .map((codec, i) => ({\n                // pair the assetId in the same order as asked for in the multi query above\n                assetId: assetIds![i],\n                balance: codec\n            }))\n        // if no assetIds were specified, fetch all balances\n        : (await apiInstance.query.tokens.accounts.entries(address))\n            .map(([storageKey, codec]) => ({\n                assetId: (storageKey.toHuman() as string[])[1],\n                balance: codec\n            }))\n\n    assetBalances?.forEach(assetBalance => {\n        // only extracting the free balance as of now\n        const balance = apiInstance?.createType(\n            assetBalanceDataType,\n            assetBalance.balance\n        ).free.toString();\n\n        balances.push({ assetId: assetBalance.assetId, balance });\n    });\n\n    // TODO: treat Balance as a top level entity for caching purposes\n    return balances;\n}\n\nexport const useGetBalancesByAddress = () => {\n    const { apiInstance, loading } = usePolkadotJsContext()\n\n    return useCallback(async (address?: string, assetIds?: string[]) => {\n        if (!apiInstance || !address) return;\n        return await getBalancesByAddress(apiInstance, address, assetIds)\n    }, [apiInstance, loading]);\n}","import { useCallback } from 'react'\nimport { Account, LbpPool, XykPool } from '../../generated/graphql';\nimport { useResolverToRef } from '../accounts/resolvers/useAccountsMutationResolvers'\nimport { useGetBalancesByAddress } from './useGetBalancesByAddress';\n\nexport const __typename = 'Balance';\nexport const useBalanceQueryResolvers = () => {\n    const getBalancesByAddress = useGetBalancesByAddress();\n    const balances = useResolverToRef(\n        useCallback(\n            /**\n             * TODO: figure out how to use @export to fetch balances only for certain assetIds\n             * then we don't have to pass in so many different entities as possible arugments here.\n             * \n             * This should also allow caching of balances if they are not fetched as a nested field,\n             * but rather a top level field per address.\n             */ \n            async (entity: Account | LbpPool | XykPool, args) => {\n                let assetIds;\n                \n                // TODO: how to extract the typename from the LbpPool[__typename] directly?\n                if (entity.__typename === 'LBPPool' || entity.__typename === 'XYKPool') {\n                    entity = (entity as LbpPool | XykPool);\n                    assetIds = [entity.assetInId, entity.assetOutId];\n                }\n\n                return (await getBalancesByAddress(entity.id, assetIds))\n                    ?.map(balance => ({\n                        ...balance,\n                        __typename,\n                        id: `${entity.id}-${balance.assetId}`,\n                    }))\n            }, \n            [getBalancesByAddress]\n        ),\n        'balances'\n    );\n\n    return {\n        balances\n    }\n}","import { useCallback } from 'react';\nimport { usePolkadotJsContext } from '../polkadotJs/usePolkadotJs'\nimport { Vec } from '@polkadot/types';\nimport { VestingScheduleOf, BalanceOf } from '@open-web3/orml-types/interfaces'\nimport { find, first } from 'lodash';\nimport { ApiPromise } from '@polkadot/api';\nimport { Codec } from '@polkadot/types/types';\n\nexport const balanceLockDataType = 'Vec<BalanceLock>';\nexport const tokensLockDataType = balanceLockDataType;\n\nexport const vestingBalanceLockId = 'ormlvest';\n\nexport const vestingScheduleDataType = 'Vec<VestingScheduleOf>';\n\nexport interface OrmlTokensBalanceLock {\n    id?: string,\n    amount?: number,\n}\n\nexport const getLockedBalanceByAddressAndLockId = async (\n    apiInstance: ApiPromise,\n    address: string,\n    lockId: string\n) => {\n    const lockedNativeBalance = find(\n        apiInstance.createType(\n            balanceLockDataType,\n            await apiInstance.query.balances.locks(address)\n        ),\n        lockedAmount => (\n            lockedAmount.id.eq(lockId)\n        )\n    );\n\n    const tokenBalanceLocks = (await apiInstance.query.tokens.locks.entries(address))\n        .map(([_storageKey, codec]: [any, Codec]) => {\n            const tokenBalanceLock = (codec.toJSON() as any)[0] as unknown as OrmlTokensBalanceLock;\n            return {\n                id: tokenBalanceLock?.id,\n                amount: tokenBalanceLock?.amount?.toString()\n            }\n        });\n    \n    const lockedTokensBalance = find(\n        tokenBalanceLocks,\n        lockedAmount => (\n            lockedAmount?.id === lockId \n        )\n    );\n    \n    return lockedNativeBalance || lockedTokensBalance;\n}\n\nexport const useGetVestingScheduleByAddress = () => {\n    const { apiInstance, loading } = usePolkadotJsContext();\n\n    const getVestingScheduleByAddress = useCallback(async (address?: string) => {\n        if (!apiInstance || !address) return;\n\n        // TODO: instead of multiple .createType calls, use the following\n        // https://github.com/AcalaNetwork/acala.js/blob/9634e2291f1723a84980b3087c55573763c8e82e/packages/sdk-core/src/functions/getSubscribeOrAtQuery.ts#L4\n        const vestingSchedule = first(\n            apiInstance.createType(\n                vestingScheduleDataType,\n                await apiInstance.query.vesting.vestingSchedules(address)\n            ) as Vec<VestingScheduleOf>\n        );\n\n        const lockedVestingAmount = await getLockedBalanceByAddressAndLockId(\n            apiInstance,\n            address,\n            vestingBalanceLockId\n        );\n\n        // TODO: are we sure this really conforms with the graphql VestingSchedule type\n        // in all conditions?\n        return {\n            // TODO: add a claimableAmount (https://gist.github.com/maht0rz/53466af0aefba004d5a4baad23f8ce26)\n            remainingVestingAmount: lockedVestingAmount?.amount?.toString(),\n            start: vestingSchedule?.start.toString(),\n            period: vestingSchedule?.period.toString(),\n            periodCount: vestingSchedule?.periodCount.toString(),\n            perPeriod: vestingSchedule?.perPeriod.toString()\n        }\n\n    }, [apiInstance, loading]);\n\n    return getVestingScheduleByAddress;\n}","import { useCallback } from 'react'\nimport { Account } from '../../generated/graphql';\nimport { useResolverToRef } from '../accounts/resolvers/useAccountsMutationResolvers'\nimport { useGetVestingScheduleByAddress } from './useGetVestingScheduleByAddress';\n\nexport const useVestingScheduleQueryResolvers = () => {\n    const getVestingScheduleByAddress = useGetVestingScheduleByAddress();\n    const vestingSchedule = useResolverToRef(\n        useCallback(\n            async (account: Account) => await getVestingScheduleByAddress(account.id), \n            [getVestingScheduleByAddress]\n        ),\n        'vestingSchedule'\n    );\n\n    return {\n        vestingSchedule\n    }\n}","import { web3Accounts, web3Enable } from '@polkadot/extension-dapp';\nimport { encodeAddress, decodeAddress } from '@polkadot/util-crypto';\nimport { find } from 'lodash';\nimport { useCallback } from 'react';\nimport { PersistedAccount } from './usePersistActiveAccount';\n\n// prefix for the ss58 address formatting of substrate addresses\nexport const basiliskAddressPrefix = 10041;\n\n/**\n * Used to fetch either all accounts, or accounts matching the given\n * set of parameters e.g. 'isActive'.\n */\nexport const useGetAccounts = () => useCallback(async (\n    persistedActiveAccountId: string | undefined,\n    isActive: boolean | undefined\n) => {\n    // TODO: use `config.appName`\n    // ensure we're connected to the polkadot.js extension\n    await web3Enable('basilisk-ui');\n\n    // get all the accounts from the polkadot.js extension\n    const accounts = (await web3Accounts())\n        // transform the returned accounts into the required entity format\n        .map(account => {\n            const address = encodeAddress(decodeAddress(account.address), basiliskAddressPrefix)\n            return {\n                id: address,\n                name: account.meta.name,\n                isActive: false,\n            };\n        })\n        // mark the active account based on the current persisted account\n        .map(account => ({\n            ...account,\n            isActive: persistedActiveAccountId == account.id,\n        }))\n\n    // if we're filtering for an active account, return just the single active account\n    if (isActive) {\n        const account = find(accounts, { isActive: isActive })\n        return account;\n    }   \n\n    // return all retrieved accounts\n    return accounts;\n}, []);","import { isArray } from 'lodash';\nimport { useCallback } from 'react';\nimport { useGetAccounts } from '../useGetAccounts';\nimport { usePersistActiveAccount } from '../usePersistActiveAccount';\nimport { useResolverToRef } from './useAccountsMutationResolvers';\n\nexport interface AccountsQueryResolverArgs {\n    isActive?: boolean\n}\n\nexport const __typename = 'Account';\n\nexport const useGetAccountsQueryResolver = () => {\n    const [persistedActiveAccount] = usePersistActiveAccount();\n    const getAccounts = useGetAccounts();\n\n    return useResolverToRef(\n        useCallback(async (\n            _obj,\n            args: AccountsQueryResolverArgs \n        ) => {\n            const accounts = await getAccounts(\n                persistedActiveAccount?.id,\n                args?.isActive,\n            );\n\n            // if no results were found, return undefined/null\n            // this is useful when un-setting the active account\n            if (!accounts) {\n                return null;\n            };\n    \n            return isArray(accounts)\n                ? accounts.map(account => ({\n                    ...account,\n                    __typename\n                }))\n                : ({\n                    // just a single account\n                    ...accounts,\n                    __typename\n                })\n        }, [\n            persistedActiveAccount,\n            getAccounts\n        ]),\n        'accounts'\n    )\n}","import { useQuery } from '@apollo/client';\nimport { loader } from 'graphql.macro';\nimport { LastBlock, Query } from '../../generated/graphql';\n\n\nexport const GET_LAST_BLOCK = loader('./graphql/GetLastBlock.query.graphql');\nexport interface GetLastBlockQueryResponse {\n    lastBlock: Query['lastBlock']\n}\n\nexport const useLastBlockQuery = () => useQuery<GetLastBlockQueryResponse>(GET_LAST_BLOCK);","import constate from 'constate';\nimport { useCallback, useEffect, useState } from 'react';\nimport { LastBlock } from '../../generated/graphql';\nimport { usePolkadotJsContext } from '../polkadotJs/usePolkadotJs'\nimport { Option } from '@polkadot/types'\nimport BN from 'bn.js';\nimport { Codec } from '@polkadot/types/types';\n\nexport const validationDataDataType = 'Option<PolkadotPrimitivesV1PersistedValidationData>';\nexport interface PolkadotPrimitivesV1PersistedValidationData {\n    relayParentNumber: number\n}\nexport type ValidationData = PolkadotPrimitivesV1PersistedValidationData\n\n// TODO: lift up using constate\nexport const useSubscribeNewBlock = () => {\n    const { apiInstance, loading } = usePolkadotJsContext();\n    const [lastBlock, setLastBlock] = useState<Partial<LastBlock> | undefined>(undefined);\n\n    const subscribeNewBlocks = useCallback(() => {\n        if (!apiInstance) return;\n        // TODO: how to unsubscribe?\n        apiInstance.derive.chain\n            .subscribeNewBlocks(async (block) => {\n                const validationData = await apiInstance.query.parachainSystem.validationData();\n\n                const validationDataOption = apiInstance.createType(\n                    validationDataDataType,\n                    validationData\n                );\n                \n                // TODO: this will only update the block if the relay chain block number is known\n                if (validationDataOption.isSome) {\n                    const validationData = validationDataOption.toJSON() as unknown as PolkadotPrimitivesV1PersistedValidationData;\n                    setLastBlock({\n                        parachainBlockNumber: block.block.header.number.toString(),\n                        relaychainBlockNumber: '821' || validationData.relayParentNumber.toString()\n                    })\n                }                \n            })\n\n    }, [apiInstance]);\n\n    useEffect(() => {\n        if (loading) return;\n        subscribeNewBlocks();\n    }, [loading, subscribeNewBlocks])\n\n    return lastBlock;\n}\n\nexport const [LastBlockProvider, useLastBlockContext] = constate(useSubscribeNewBlock);","import { ApolloCache, ApolloClient, NormalizedCacheObject, useApolloClient } from '@apollo/client';\nimport { relativeTimeRounding } from 'moment';\nimport { useEffect } from 'react';\nimport { LastBlock } from '../../generated/graphql';\nimport { GetLastBlockQueryResponse, GET_LAST_BLOCK } from './useLastBlockQuery';\nimport { useLastBlockContext } from './useSubscribeNewBlockNumber'\n\nexport const __typename = 'LastBlock';\nexport const id = __typename;\n\nexport const writeLastBlock = (cache: ApolloCache<NormalizedCacheObject>, lastBlock: LastBlock) => {\n    return cache.writeQuery<GetLastBlockQueryResponse>({\n        query: GET_LAST_BLOCK,\n        data: {\n            lastBlock\n        }\n    })\n}\nexport const useRefetchWithNewBlock = (client: ApolloClient<NormalizedCacheObject>) => {\n    const lastBlock = useLastBlockContext();\n\n    useEffect(() => {\n        writeLastBlock(client.cache, {\n            __typename,\n            id,\n            ...lastBlock\n        });\n    }, []);\n\n    useEffect(() => {\n        if (!lastBlock) return;\n\n        const lastBlockData = client.cache.readQuery<GetLastBlockQueryResponse>({\n            query: GET_LAST_BLOCK\n        });\n\n        if (!lastBlockData?.lastBlock?.parachainBlockNumber) {\n            // received the first real lastBlockNumber, don't refetch just yet\n            writeLastBlock(client.cache, {\n                __typename,\n                id,\n               ...lastBlock\n            })\n        } else {\n            // lastBlockNumber has been updated, and it's not the first time\n            // refetch queries that depend on the lastBlockNumber\n            client.refetchQueries({\n                updateCache(cache) {\n                    writeLastBlock(cache, {\n                        __typename,\n                        id,\n                        ...lastBlock\n                    })\n                }\n            })\n        }\n    }, [lastBlock]);\n}","import { useApolloClient, useQuery } from '@apollo/client';\nimport constate from 'constate';\nimport { loader } from 'graphql.macro'\nimport { useEffect } from 'react';\nimport { Account, LastBlock, Query } from '../../../generated/graphql';\nimport { GET_CONFIG } from '../../config/useGetConfigQuery';\n\nexport const GET_ACTIVE_ACCOUNT = loader('./../graphql/GetActiveAccount.query.graphql');\n\nexport interface GetActiveAccountQueryResponse {\n    account: Query['account'],\n    lastBlock: Query['lastBlock'],\n}\n\n// TODO: turn this into a lazy query instead, so it does not get fetched right away\nexport const useGetActiveAccountQuery = () => {\n    const client = useApolloClient();\n    const result = useQuery<GetActiveAccountQueryResponse>(GET_ACTIVE_ACCOUNT, {\n        notifyOnNetworkStatusChange: true,\n    });\n\n    // when the active account updates, refetch the config\n    // since the config for `feePaymentAsset` depends on the active account\n    useEffect(() => {\n        client.refetchQueries({\n            // include: [GET_CONFIG]\n        });\n    }, [result.data?.account?.id])\n\n    return result;\n}\nexport const [GetActiveAccountQueryProvider, useGetActiveAccountQueryContext] = constate(useGetActiveAccountQuery);","import { useCallback } from 'react'\nimport { useResolverToRef } from '../accounts/resolvers/useAccountsMutationResolvers'\nimport { usePolkadotJsContext } from '../polkadotJs/usePolkadotJs'\nimport { web3FromAddress } from '@polkadot/extension-dapp';\nimport { ClaimVestedAmountMutationVariables } from './useClaimVestedAmountMutation';\nimport { ExtrinsicStatus } from '@polkadot/types/interfaces/author';\nimport { DispatchError, EventRecord } from '@polkadot/types/interfaces/system';\nimport log from 'loglevel';\nimport { ApolloCache, NormalizedCacheObject } from '@apollo/client';\nimport { GetActiveAccountQueryResponse, GET_ACTIVE_ACCOUNT } from '../accounts/queries/useGetActiveAccountQuery';\nimport { ApiPromise } from '@polkadot/api';\n\n/**\n * Run an async function and handle the thrown errors\n * with an array of error handlers, which may handle the errors gracefully\n * \n * @param fn \n * @param errorHandlers \n * @returns \n */\nexport type resolve = (result?: any) => void;\nexport type reject = (error?: any) => void;\nexport const withGracefulErrors = async (\n    fn: (resolve: resolve, reject: reject) => Promise<any>,\n    errorHandlers: ((error: any) => void)[]\n) => {\n    return new Promise<any>(async (resolve, reject) => {\n        try {\n            resolve(await fn(resolve, reject));\n        } catch (e: any) {\n            console.log('graceful error', e);\n            e = errorHandlers.reduce((e, errorHandler) => errorHandler(e), e);\n            // rejecting this promise with an error instead of throwing an error\n            // is necessary to reflect the apollo resolver loading state correctly\n            e ? reject(e) : resolve(null)\n        }\n    })\n}\n\nexport const cancelledErrorMessage = 'Cancelled';\n\n/**\n * This is an example graceful error handler,\n * if this would return `e` instead of `void`,\n * then the following graceful error handler would be triggered,\n * or by default the error would be thrown.\n * \n * @param e\n * @returns \n */\nexport const gracefulExtensionCancelationErrorHandler = (e: any) => {\n    if ((e as Error)?.message === cancelledErrorMessage) {\n        log.error('Operation presumably cancelled by the user in the Polkadot.js extension')\n        return;\n    }\n    return e;\n}\n\nexport const vestingClaimHandler = (resolve: resolve, reject: reject, apiInstance?: ApiPromise) => ({\n    status,\n    events = [],\n    dispatchError\n}: {\n    status: ExtrinsicStatus,\n    events: EventRecord[],\n    dispatchError?: DispatchError\n}) => {\n    if (status.isFinalized) log.info('operation finalized')\n\n    // TODO: extract intention registred for exchange buy/sell\n    events.forEach(({ event: { data, method, section }, phase }) => {\n        console.log('event handler', phase.toString(), `: ${section}.${method}`, data.toString());\n    });\n\n    // TODO: handle status via the action log / notification stack\n    if (status.isInBlock) {\n        console.log('is in block', status.createdAtHash?.toString());\n        if (dispatchError?.isModule) {\n            return log.info('operation unsuccessful',\n                !apiInstance\n                    ? dispatchError\n                    : apiInstance.registry.findMetaError(dispatchError.asModule)\n            );\n        }\n\n        return log.info('operation successful');\n    }\n\n    // if the operation has been broadcast, finish the mutation\n    if (status.isBroadcast) {\n        log.info('transaction has been broadcast', status.hash.toHuman());\n        return resolve();\n    }\n    if (dispatchError) {\n        log.error('There was a dispatch error', dispatchError);\n        return reject('Dispatch error');\n    }\n};\n\nexport const noAccountSelectedError = 'No Account selected';\nexport const polkadotJsNotReadyYetError = 'Polkadot.js is not ready yet';\n\nexport const useVestingMutationResolvers = () => {\n    const { apiInstance, loading } = usePolkadotJsContext();\n\n    const claimVestedAmount = useResolverToRef(\n        useCallback(async (\n            _obj,\n            variables: ClaimVestedAmountMutationVariables,\n            { cache }: { cache: ApolloCache<NormalizedCacheObject> }\n        ) => {\n            const address = variables?.address\n                ? variables.address\n                : cache.readQuery<GetActiveAccountQueryResponse>({\n                    query: GET_ACTIVE_ACCOUNT\n                })?.account?.id;\n\n            // TODO: error handling?\n            if (!address) throw new Error(noAccountSelectedError);\n            if (loading || !apiInstance) throw new Error(polkadotJsNotReadyYetError);\n\n            // // TODO: why does this not return a tx hash?\n            return await withGracefulErrors(async (resolve, reject) => {\n                const { signer } = await web3FromAddress(address);\n                await apiInstance.tx.vesting.claim()\n                    .signAndSend(\n                        address,\n                        { signer },\n                        vestingClaimHandler(resolve, reject)\n                    )\n            }, [\n                gracefulExtensionCancelationErrorHandler\n            ])\n\n        }, [loading, apiInstance]),\n        'claimVestedAmount'\n    )\n\n    return {\n        claimVestedAmount\n    }\n}","import { web3FromAddress } from '@polkadot/extension-dapp';\nimport { useCallback, useEffect, useMemo, useState } from 'react';\nimport { useResolverToRef } from '../accounts/resolvers/useAccountsMutationResolvers';\nimport { usePolkadotJsContext } from '../polkadotJs/usePolkadotJs'\nimport { gracefulExtensionCancelationErrorHandler, polkadotJsNotReadyYetError, reject, resolve, withGracefulErrors } from '../vesting/useVestingMutationResolvers';\nimport { TransferBalanceMutationVariables } from './useTransferBalanceMutation';\nimport { ExtrinsicStatus } from '@polkadot/types/interfaces/author';\nimport { DispatchError } from '@polkadot/types/interfaces/system';\nimport log from 'loglevel';\nimport { ApiPromise } from '@polkadot/api';\nimport { RuntimeDispatchInfo } from '@polkadot/types/interfaces/payment';\n\n// TODO: use validate JSON schema module of some sort\nexport const invalidTransferVariablesError = 'Invalid transfer parameters provided';\n\nexport const transferBalanceHandler = (\n    apiInstance: ApiPromise,\n    resolve: resolve, \n    reject: reject\n) => ({\n    status,\n    dispatchError\n}: {\n    status: ExtrinsicStatus,\n    dispatchError?: DispatchError\n}) => {\n    if (status.isFinalized) log.info('operation finalized')\n\n    // TODO: handle status via the action log / notification stack\n    if (status.isInBlock) {\n        if (dispatchError?.isModule) {\n            return log.error('transfer unsuccessful', \n                apiInstance.registry.findMetaError(dispatchError.asModule)\n            );\n        }\n\n        return log.info('transfer successful');\n    }\n\n    // if the operation has been broadcast, finish the mutation\n    if (status.isBroadcast) {\n        log.info('transaction has been broadcast');\n        return resolve();\n    }\n    if (dispatchError) {\n        log.error('There was a dispatch error', \n            apiInstance.registry.findMetaError(dispatchError.asModule)\n        );\n        return reject();\n    }\n}\n\nexport const transferBalanceExtrinsic = (apiInstance: ApiPromise) => apiInstance.tx.currencies.transfer;\n\nexport const useEstimateTransferBalance = ({ from, to, currencyId, amount }: TransferBalanceMutationVariables) => {\n    const { apiInstance } = usePolkadotJsContext();\n    const [paymentInfo, setPaymentInfo] = useState<RuntimeDispatchInfo | undefined>(undefined);\n\n    const estimatePaymentInfo = useCallback(async () => {\n        if (!apiInstance || !from || !to || !currencyId || !amount) return setPaymentInfo(undefined);\n        \n        const paymentInfo = await transferBalanceExtrinsic(apiInstance)\n                .apply(apiInstance, [to, currencyId, amount])\n                .paymentInfo(from);\n        \n        setPaymentInfo(paymentInfo);\n\n    }, [apiInstance, from, to, currencyId, amount, setPaymentInfo]);\n\n    return { estimatePaymentInfo, paymentInfo };\n}\n\nexport const useBalanceMutationResolvers = () => {\n    const { apiInstance, loading } = usePolkadotJsContext();\n\n    const transferBalance = useResolverToRef(\n        useCallback(async (\n            _obj,\n            { from, to, currencyId, amount }: TransferBalanceMutationVariables\n        ) => {\n            if (!from || !to || !currencyId || !amount) throw new Error(invalidTransferVariablesError);\n            if (loading || !apiInstance) throw new Error(polkadotJsNotReadyYetError);\n\n            return withGracefulErrors(async (resolve, reject) => {\n                const { signer } = await web3FromAddress(from);\n                await transferBalanceExtrinsic(apiInstance).apply(apiInstance, [to, currencyId, amount])\n                    .signAndSend(\n                        from,\n                        { signer },\n                        transferBalanceHandler(apiInstance, resolve, reject)\n                    )\n            }, [\n                gracefulExtensionCancelationErrorHandler\n            ]);\n        }, [apiInstance, loading])\n    )\n\n    return {\n        transferBalance\n    }\n}","import { web3Enable } from '@polkadot/extension-dapp';\nimport { useCallback } from 'react'\nimport { useResolverToRef } from '../accounts/resolvers/useAccountsMutationResolvers'\n\nexport const __typename = 'Extension';\nexport const id = __typename;\nexport const useExtensionQueryResolvers = () => {\n    /**\n     * TODO: handle the followingc cases gracefully:\n     * - pending authorization request exists\n     * - user rejects the connection in the extension\n     * - app tries to connect again, after the connection has been rejected\n     */\n    const extension = useResolverToRef(\n        useCallback(async () => {\n            const extensions = await web3Enable('basilisk-ui');\n            return {\n                __typename,\n                id,\n                isAvailable: !!extensions.length,\n            };\n        }, [])\n    )\n\n    return {\n        extension\n    }\n}","import { ApolloCache, NormalizedCacheObject } from '@apollo/client';\nimport { useCallback } from 'react'\nimport { useResolverToRef } from '../accounts/resolvers/useAccountsMutationResolvers'\nimport { GetActiveAccountQueryResponse, GET_ACTIVE_ACCOUNT } from '../accounts/queries/useGetActiveAccountQuery';\nimport { usePolkadotJsContext } from '../polkadotJs/usePolkadotJs';\nimport { usePersistentConfig } from './usePersistentConfig';\n\nexport const accountCurrencyMapDataType = 'Option<u32>';\n\nexport const __typename = 'Config';\nexport const id = __typename;\n\nexport const nativeAssetId = '0';\n\nexport const useConfigQueryResolvers = () => {\n    const [persistedConfig] = usePersistentConfig();\n    const { apiInstance, loading } = usePolkadotJsContext();\n\n    const config = useResolverToRef(\n        useCallback(async (\n            _obj,\n            _variables,\n            { cache }: { cache: ApolloCache<NormalizedCacheObject> }\n        ) => {\n            if (!apiInstance || loading) return;\n\n            // TODO: evict config from the cache after active account changes\n            const address = cache.readQuery<GetActiveAccountQueryResponse>({\n                query: GET_ACTIVE_ACCOUNT\n            })?.account?.id;\n\n            let feePaymentAsset =  address\n                ? apiInstance.createType(\n                    accountCurrencyMapDataType,\n                    await apiInstance.query.multiTransactionPayment.accountCurrencyMap(address)\n                )?.toHuman()\n                : null\n\n            feePaymentAsset = feePaymentAsset ? feePaymentAsset : nativeAssetId\n            \n            return {\n                __typename,\n                id,\n                ...persistedConfig,\n                feePaymentAsset\n            };\n        }, [apiInstance, loading])\n    );\n\n    return {\n        config\n    }\n}","import { ApolloCache, NormalizedCacheObject } from '@apollo/client';\nimport { web3FromAddress } from '@polkadot/extension-dapp';\nimport { useCallback } from 'react'\nimport { useResolverToRef } from '../accounts/resolvers/useAccountsMutationResolvers'\nimport { GetActiveAccountQueryResponse, GET_ACTIVE_ACCOUNT } from '../accounts/queries/useGetActiveAccountQuery';\nimport { usePolkadotJsContext } from '../polkadotJs/usePolkadotJs';\nimport { gracefulExtensionCancelationErrorHandler, reject, resolve, vestingClaimHandler, withGracefulErrors } from '../vesting/useVestingMutationResolvers';\nimport { defaultConfigValue, usePersistentConfig } from './usePersistentConfig';\nimport { SetConfigMutationVariables } from './useSetConfigMutation';\n\nexport const defaultAssetId = '0';\n\nexport const setCurrencyHandler = (resolve: resolve, reject: reject) => {\n    return vestingClaimHandler(resolve, reject);\n}\n\nexport const useConfigMutationResolvers = () => {\n    const { apiInstance, loading } = usePolkadotJsContext();\n    const [_persistedConfig, setPersistedConfig] = usePersistentConfig();\n\n    const setConfig = useResolverToRef(\n        useCallback(async (\n            _obj,\n            args: SetConfigMutationVariables,\n            { cache }: { cache: ApolloCache<NormalizedCacheObject> }\n        ) => {\n            // TODO: error handling?\n            if (!apiInstance || loading) return;\n\n            // TODO: return an optimistic update to the cache with the new config\n            await withGracefulErrors(async (resolve, reject) => {\n                const address = cache.readQuery<GetActiveAccountQueryResponse>({\n                    query: GET_ACTIVE_ACCOUNT\n                })?.account?.id;\n\n                if (!address) return resolve();\n\n                const { signer } = await web3FromAddress(address);\n                \n                await apiInstance.tx.multiTransactionPayment.setCurrency(\n                    args.config?.feePaymentAsset || defaultAssetId\n                )\n                    .signAndSend(\n                        address,\n                        { signer },\n                        setCurrencyHandler(resolve, reject)\n                    )\n            }, [\n                gracefulExtensionCancelationErrorHandler\n            ]);\n            \n            const persistableConfig = args.config;\n            // there's no point in persisting the feePaymentAsset since it will\n            // be refetched from the node anyways\n            delete persistableConfig?.feePaymentAsset;\n            \n            setPersistedConfig(() => persistableConfig || defaultConfigValue);\n        }, [apiInstance, loading])\n    );\n\n    return {\n        setConfig\n    }\n}","import { useCallback } from 'react'\nimport { FeePaymentAsset } from '../../generated/graphql';\nimport { useResolverToRef } from '../accounts/resolvers/useAccountsMutationResolvers'\nimport { usePolkadotJsContext } from '../polkadotJs/usePolkadotJs';\n\nexport const __typename: FeePaymentAsset['__typename'] = 'FeePaymentAsset';\nexport const useFeePaymentAssetsQueryResolvers = () => {\n    const { apiInstance, loading } = usePolkadotJsContext();\n    const feePaymentAssets = useResolverToRef(\n        useCallback(async () => {\n            if (!apiInstance || loading) return;\n\n            const acceptedCurrencies = await apiInstance.query.multiTransactionPayment.acceptedCurrencies.entries()\n            const feePaymentAssets: FeePaymentAsset[] = acceptedCurrencies.map((acceptedCurrency) => {\n                const assetId = (acceptedCurrency[0].toHuman() as string[])[0];\n                return {\n                    // TODO: is there a safer type way to do this?\n                    // TODO: maybe? combine this with known asset data\n                    __typename,\n                    id: assetId,\n                    assetId: assetId,\n                    fallbackPrice: acceptedCurrency[1].toString()\n                }\n            })\n            \n            return feePaymentAssets;\n        }, [apiInstance, loading])\n    );\n\n    return {\n        feePaymentAssets\n    }\n}","import constate from 'constate';\nimport { useEffect, useState } from 'react'\n\n// TODO: figure out how to extract types from the wasm type definitions\nexport interface HydraDxMathXyk {\n    get_spot_price: (a: string, b: string, c: string) => string | undefined,\n    calculate_in_given_out: (a: string, b: string, c: string) => string | undefined,\n    calculate_out_given_in: (a: string, b: string, c: string) => string | undefined\n}\n\nexport interface HydraDxMathLbp {\n    calculate_linear_weights: (start_x: string, end_x: string, start_y: string, end_y: string, at: string) => string,\n    calculate_in_given_out: (s: string, b: string, s_w: string, b_w: string, a: string) => string,\n    calculate_out_given_in: (s: string, b: string, s_w: string, b_w: string, a: string) => string,\n    get_spot_price: (s: string, b: string, s_w: string, b_w: string, a: string) => string,\n}\n\nexport interface HydraDxMath {\n    xyk: HydraDxMathXyk,\n    lbp: HydraDxMathLbp\n}\n\nexport const loadMath = async (): Promise<HydraDxMath> => {\n    return {\n        xyk: await import('hydra-dx-wasm/build/xyk/bundler'),\n        lbp: await import('hydra-dx-wasm/build/lbp/bundler') as unknown as HydraDxMathLbp\n    }\n}\n\n/**\n * Load the wasm math module\n * @returns \n */\nexport const useMath = () => {\n    const [wasm, setWasm] = useState<{\n        instance: HydraDxMath | undefined,\n        loading: boolean\n    } | undefined>({\n        instance: undefined,\n        loading: true,\n    });\n\n    useEffect(() => {\n        (async () => {\n            setWasm({\n                // TODO: if the module path is a variable, the module can't be found for some reason\n                instance: await loadMath(),\n                loading: false,\n            });\n        })();\n    }, [setWasm])\n\n    // TODO if we need additional math functions outside of wasm,\n    // inject them here\n    return { math: wasm?.instance, loading: wasm?.loading };\n}\n\nexport const [MathProvider, useMathContext] = constate(useMath);","import { useCallback } from 'react';\nimport { XykPool } from '../../generated/graphql';\nimport { usePolkadotJsContext } from '../polkadotJs/usePolkadotJs'\nimport type { StorageKey } from '@polkadot/types';\nimport type { AnyTuple, Codec } from '@polkadot/types/types';\nimport { ApiPromise } from '@polkadot/api';\n\nexport type PoolAssets = string[];\nexport const poolAssetsDataType = '(u32, u32)';\n\nexport const mapToPoolId = ([storageKey, codec]: [StorageKey<AnyTuple>, Codec]): [string, Codec] => {\n    const id = (storageKey.toHuman() as string[])[0];\n    return [id, codec];\n}\n\nexport const mapToPool = (apiInstance: ApiPromise) => ([id, codec]: [string, Codec]) => {\n    const poolAssets = codec.toHuman() as PoolAssets;\n\n    if (!poolAssets) return;\n\n    return {\n        id,\n        assetInId: poolAssets[0],\n        assetOutId: poolAssets[1],\n    } as XykPool\n}\n\nexport const useGetXykPools = () => {\n    const { apiInstance, loading } = usePolkadotJsContext();\n\n    return useCallback(async (poolId?: string, assetIds?: string[]) => {\n        if (!apiInstance || loading) return [];\n\n        if (poolId) {\n            return [(await apiInstance.query.xyk.poolAssets(poolId))]\n                .map(pool => [poolId, pool] as [string, Codec])\n                .map(mapToPool(apiInstance))\n        }\n    \n        return (await apiInstance.query.xyk.poolAssets.entries())\n            .map(mapToPoolId)  \n            .map(mapToPool(apiInstance)) || []\n    }, [\n        apiInstance,\n        loading\n    ])\n}","import BigNumber from 'bignumber.js'\n\nexport const hundredWithPrecision6 = new BigNumber('100')\n    .multipliedBy(\n        new BigNumber('10').pow('6')\n    )\n\n/**\n * LBP pools specify weights only for the first asset in the pool,\n * the `opposite` weights need to be calculated by subtracting from `100`\n * @param weight \n * @returns Calculated oppostite weight as `100 - weight`\n */\nexport const calculateOppositeAssetWeight = (weight: string): string => {\n    return new BigNumber(hundredWithPrecision6)\n        .minus(\n            new BigNumber(weight)\n        )\n        .toFixed(0)\n}\n","import { LbpAssetWeights, LbpPool, Pool } from '../../../generated/graphql';\nimport { HydraDxMath } from '../../math/useMath';\n\n/**\n * Used to determine the current asset weight, given the initial/final weights \n * and the interval it should be interpolated on.\n * \n * @param math \n * @param pool \n * @param weights \n * @param relaychainBlockNumber \n * @returns Current asset weight, calculated lineary from the inputs above\n */\nexport const calculateCurrentAssetWeight = (\n    math: HydraDxMath,\n    pool: Pick<LbpPool, 'startBlock' | 'endBlock'>,\n    weights: Pick<LbpAssetWeights, 'initial' | 'final'>,\n    relaychainBlockNumber: string\n): string => {\n    return math.lbp.calculate_linear_weights(\n        pool.startBlock,\n        pool.endBlock,\n        weights.initial,\n        weights.final,\n        relaychainBlockNumber\n    );\n}","import { ApolloCache } from '@apollo/client';\nimport { GetLastBlockQueryResponse, GET_LAST_BLOCK } from './useLastBlockQuery';\n\nexport const readLastBlock = (cache: ApolloCache<object>) => {\n  return cache.readQuery<GetLastBlockQueryResponse>({\n    query: GET_LAST_BLOCK,\n  });\n};\n","import { ApiPromise } from '@polkadot/api';\nimport { useCallback } from 'react';\nimport { Fee, LbpAssetWeights, LbpPool } from '../../generated/graphql';\nimport { usePolkadotJsContext } from '../polkadotJs/usePolkadotJs';\nimport type { Codec } from '@polkadot/types/types';\nimport { mapToPoolId } from './useGetXykPools';\nimport { calculateOppositeAssetWeight } from './lbp/calculateOppositeAssetWeight';\nimport { HydraDxMath, useMathContext } from '../math/useMath';\nimport { calculateCurrentAssetWeight } from './lbp/calculateCurrentAssetWeight';\nimport { ApolloClient } from '@apollo/client';\nimport { readLastBlock } from '../lastBlock/readLastBlock';\nimport { getLockedBalanceByAddressAndLockId } from '../vesting/useGetVestingScheduleByAddress';\nimport BigNumber from 'bignumber.js';\n\nexport type AssetPair = number[];\nexport interface PoolData {\n  assets: AssetPair;\n  feeCollector: string;\n  fee: {\n    numerator: number;\n    denominator: number;\n  };\n  repayTarget: number;\n  initialWeight: number;\n  finalWeight: number;\n  start: number;\n  end: number;\n}\n\n// ID isnt parsed when converting the codec into a JSON\nexport const lbpRepayFeeLockId = '0x6c6270636c6c6374'; // 'lbpcllct';\nexport const balanceDataType = 'BalanceOf';\n\n// fee applied in a case when the repayTarget has not been reached\nconst repayFee: Fee = {\n  numerator: '2',\n  denominator: '10',\n};\n\n/**\n * @param math\n * @param client\n * @returns Function to format the given codec into an LBPPool\n */\nexport const mapToPool =\n  (math: HydraDxMath, client: ApolloClient<object>, apiInstance: ApiPromise) =>\n  /**\n   * @param [id, codec]\n   * @returns LBPPool parsed from the coded provided as an argument\n   */\n  async ([id, codec]: [string, Codec]) => {\n    // TODO this is possibly VERY unsafe and needs to be revisited for type parsing / creation\n    const poolData = codec.toJSON() as unknown as PoolData;\n    const lastBlockData = readLastBlock(client.cache);\n    const relaychainBlockNumber =\n      lastBlockData?.lastBlock?.relaychainBlockNumber;\n\n    if (!poolData || !relaychainBlockNumber) return;\n\n    const feeCollector = poolData.feeCollector.toString();\n    const repayTarget = apiInstance\n      .createType(balanceDataType, poolData.repayTarget.toString())\n      .toString();\n\n    // construct the pool entity without weights\n    const partialPool: Omit<\n      LbpPool,\n      'assetBWeights' | 'assetAWeights' | 'repayTargetReached' | 'fee'\n    > = {\n      id,\n      assetInId: poolData.assets[0].toString(),\n      assetOutId: poolData.assets[1].toString(),\n      startBlock: poolData.start.toString(),\n      endBlock: poolData.end.toString(),\n    };\n\n    // determine weights for asset A\n    const partialAssetAWeights: Omit<LbpAssetWeights, 'current'> = {\n      initial: poolData.initialWeight.toString(),\n      final: poolData.finalWeight.toString(),\n    };\n\n    const assetAWeights: LbpAssetWeights = {\n      ...partialAssetAWeights,\n      current: calculateCurrentAssetWeight(\n        math,\n        partialPool,\n        partialAssetAWeights,\n        relaychainBlockNumber\n      ),\n    };\n\n    // determine weights for asset B\n    const assetBWeights: LbpAssetWeights = {\n      initial: calculateOppositeAssetWeight(assetAWeights.initial),\n      final: calculateOppositeAssetWeight(assetAWeights.final),\n      current: calculateOppositeAssetWeight(assetAWeights.current),\n    };\n\n    // TODO: this function only works by finding the first lock with the given ID\n    // TODO: this data fetching should be moved to a resolver, and this mapper\n    // should be a plain function\n    const feeCollectorBalanceLockAmount = (\n      await getLockedBalanceByAddressAndLockId(\n        apiInstance,\n        feeCollector,\n        lbpRepayFeeLockId\n      )\n    )?.amount?.toString();\n\n    const repayTargetReached =\n      repayTarget && feeCollectorBalanceLockAmount\n        ? // if collected fees are greater than the repay target, the repay target has been reached\n          // this means that we won't apply the repay fee down the line\n          new BigNumber(feeCollectorBalanceLockAmount).gt(\n            new BigNumber(repayTarget)\n          )\n        : false;\n\n    const poolFee: Fee = {\n      numerator: poolData.fee.numerator.toString(),\n      denominator: poolData.fee.denominator.toString(),\n    };\n\n    const pool: LbpPool = {\n      ...partialPool,\n      assetAWeights,\n      assetBWeights,\n      repayTargetReached,\n      // if we've haven't reached the repay target, the pool will carry a larger fee\n      fee: repayTargetReached ? poolFee : repayFee,\n    };\n\n    return pool;\n  };\n\nexport const getLbpPools = async (\n  apiInstance: ApiPromise,\n  math: HydraDxMath,\n  client: ApolloClient<object>\n) => {\n  return (\n    (await Promise.all(\n      (await apiInstance.query.lbp.poolData.entries())\n        .map(mapToPoolId)\n        .map(mapToPool(math, client, apiInstance))\n    )) || []\n  );\n};\n\n/**\n * Hook to fetch and map LBPPool data\n * @returns Function that returns the on-chain LBPPool(s)\n */\nexport const useGetLbpPools = () => {\n  const { apiInstance, loading } = usePolkadotJsContext();\n  const { math } = useMathContext();\n\n  return useCallback(\n    async (client: ApolloClient<object>) => {\n      // return an empty array by default\n      if (!apiInstance || loading || !math) return [];\n      return getLbpPools(apiInstance, math, client);\n    },\n    [apiInstance, loading, math]\n  );\n};\n","import { ApolloClient } from '@apollo/client';\nimport { ApiPromise } from '@polkadot/api';\nimport log from 'loglevel';\nimport { useCallback } from 'react';\nimport { HydraDxMath, useMathContext } from '../math/useMath';\nimport { usePolkadotJsContext } from '../polkadotJs/usePolkadotJs'\nimport { mapToPool } from './useGetLbpPools';\n\nexport const getLbpPool = async (\n    math: HydraDxMath,\n    client: ApolloClient<object>,\n    apiInstance: ApiPromise,\n    poolId: string,\n) => {\n    return await mapToPool(math, client, apiInstance)([\n        poolId,\n        await apiInstance.query.lbp.poolData(poolId)\n    ])\n}\n\nexport const useGetLbpPool = () => {\n    const { apiInstance } = usePolkadotJsContext();\n    const { math } = useMathContext();\n\n    return useCallback(async (\n        client: ApolloClient<object>, \n        poolId?: string\n    ) => {\n        log.debug('useGetLbpPool', apiInstance, poolId, math)\n        if (!apiInstance || !poolId || !math) return;\n        return getLbpPool(math, client, apiInstance, poolId);\n    }, [apiInstance, math])\n}","import { ApolloClient } from '@apollo/client';\nimport { ApiPromise } from '@polkadot/api';\nimport { Codec } from '@polkadot/types/types';\nimport { isArray, isObject } from 'lodash';\nimport log from 'loglevel';\nimport { useCallback } from 'react';\nimport { PoolType } from '../../../components/Chart/shared';\nimport { LbpPool, XykPool } from '../../../generated/graphql';\nimport { useResolverToRef } from '../../accounts/resolvers/useAccountsMutationResolvers';\nimport { __typename } from '../../accounts/resolvers/useGetAccountsQueryResolver';\nimport { usePolkadotJsContext } from '../../polkadotJs/usePolkadotJs';\nimport { useGetLbpPool } from '../useGetLbpPool';\nimport { useGetLbpPools } from '../useGetLbpPools';\nimport { useGetXykPool } from '../useGetXykPool';\nimport { useGetXykPools } from '../useGetXykPools';\n\nexport interface PoolQueryResolverArgs {\n    poolId?: string,\n    assetIds?: string[],\n    poolType?: PoolType\n}\n// Filter those out, until the following issue is implemented\n// https://github.com/galacticcouncil/Basilisk-node/issues/248\nexport const defaultLbpPoolId = 'bXnAY36Vvd3HdWTX5v1Cgej2tYFsq1UpzShWyAQAr5HQ9FaJx';\nexport const defaultXykPoolId = 'bXnAY36Vvd3HdWTX5v1Cgej2tYFsq1UpzShWyAQAr5HQ9FaJx';\n\nexport interface PoolIds {\n    lbpPoolId?: string,\n    xykPoolId?: string\n}\n\nexport const getPoolIdsByAssetIds = async (apiInstance: ApiPromise, assetIds: string[]) => {\n    let lbpPoolId: string | undefined = (await (apiInstance.rpc as any).lbp.getPoolAccount(\n        assetIds[0], assetIds[1]\n    )).toHuman();\n    \n    let xykPoolId: string | undefined = (await (apiInstance.rpc as any).xyk.getPoolAccount(\n        assetIds[0], assetIds[1]\n    )).toHuman();\n\n    return {\n        lbpPoolId,\n        xykPoolId\n    }\n}\n\nexport const useGetPoolsQueryResolver = () => {\n    const { apiInstance, loading } = usePolkadotJsContext();\n    const getLbpPools = useGetLbpPools();\n    const getXykPools = useGetXykPools();\n    const getXykPool = useGetXykPool();\n    const getLbpPool = useGetLbpPool();\n\n    return useResolverToRef(\n        useCallback(async (\n            _obj,\n            args?: PoolQueryResolverArgs,\n            context?: { client: ApolloClient<object> }\n        ) => {\n            if (!apiInstance || loading || !context?.client) return;\n            log.debug('useGetPoolsQueryResolver', 'fetching pools', args);\n\n            // use the provided poolId\n            let poolId = args?.poolId;\n            let poolIds: PoolIds = {\n                lbpPoolId: poolId,\n                xykPoolId: poolId\n            };\n\n            // if we're querying by assetIds, find the poolIds via RPC\n            if (args?.assetIds) {\n                poolIds = await getPoolIdsByAssetIds(apiInstance, args.assetIds);\n                log.debug('useGetPoolsQueryResolver', 'found poolIDs', poolIds, apiInstance);\n            }\n\n            // if the poolId is specified, try resolving with a single pool\n            if (poolIds.xykPoolId || poolIds.lbpPoolId) {\n                let lbpPool = await getLbpPool(context.client, poolIds.lbpPoolId);\n                let xykPool = await getXykPool(poolIds.xykPoolId);\n        \n                log.debug('useGetPoolsQueryResolver', 'found pools by poolIDs', lbpPool, xykPool);\n\n                // if the assets are matching, its a default value which means the pool was not found\n                if (xykPool?.assetInId === xykPool?.assetOutId) xykPool = undefined;\n                if (lbpPool?.assetInId === lbpPool?.assetOutId) lbpPool = undefined;\n\n                log.debug('useGetPoolsQueryResolver', 'eliminated default value pools', lbpPool, xykPool);\n\n                // TODO: which pool should have priority if both types exist for the same assets?\n                const pool = xykPool || lbpPool;\n                \n                log.debug('useGetPoolsQueryResolver', 'returning a single pool', pool);\n\n                return pool && ({\n                    ...pool,\n                    __typename: xykPool \n                        ? 'XYKPool' as XykPool['__typename']\n                        : lbpPool\n                            ? 'LBPPool' as LbpPool['__typename']\n                            : undefined\n                })\n            }\n\n            // if no extra args were provided, get all the pools\n            const [lbpPools, xykPools] = await Promise.all([\n                getLbpPools(context.client),\n                getXykPools()\n            ]);\n            \n            log.debug('useGetPoolsQueryResolver', 'returning multiple pools', [lbpPools, xykPools]);\n\n            return ([] as (LbpPool | XykPool)[])\n                .concat(\n                    lbpPools\n                        ?.map(pool => ({\n                            ...pool,\n                            __typename: 'LBPPool'\n                        }) as LbpPool)\n                )\n                .concat(\n                    xykPools\n                        ?.map(pool => ({\n                            ...pool,\n                            __typename: 'XYKPool'\n                        }) as XykPool)\n                )\n\n        }, [getLbpPools]),\n        'pools'\n    )\n}","import { useCallback } from 'react';\nimport { usePolkadotJsContext } from '../polkadotJs/usePolkadotJs'\nimport { mapToPool } from './useGetXykPools';\n\nexport const useGetXykPool = () => {\n    const { apiInstance, loading } = usePolkadotJsContext();\n\n    return useCallback(async (poolId?: string) => {\n        if (!apiInstance || loading || !poolId) return;\n\n        return mapToPool(apiInstance)([\n            poolId,\n            await apiInstance.query.xyk.poolAssets(poolId)\n        ]);\n    }, [\n        apiInstance,\n        loading\n    ])\n}","import { useCallback } from 'react';\nimport { Asset } from '../../../generated/graphql';\nimport { useResolverToRef } from '../../accounts/resolvers/useAccountsMutationResolvers';\nimport { usePolkadotJsContext } from '../../polkadotJs/usePolkadotJs'\nimport { useGetAssets } from '../useGetAssets';\n\nexport const __typename: Asset['__typename'] = 'Asset';\n\nexport const useGetAssetsQueryResolver = () => {\n    const { apiInstance, loading } = usePolkadotJsContext();\n    const getAssets = useGetAssets();\n\n    return useResolverToRef(\n        useCallback(async () => {\n            return (await getAssets())\n                ?.map(asset => ({\n                    ...asset,\n                    __typename\n                }))\n        }, [\n            apiInstance,\n            loading\n        ])\n    )\n}","import { useCallback } from 'react';\nimport { usePolkadotJsContext } from '../polkadotJs/usePolkadotJs'\nimport type { Codec } from '@polkadot/types/types';\nimport { ApiPromise } from '@polkadot/api';\nimport { Asset } from '../../generated/graphql';\n\nexport const assetDataType = 'Option<u32>';\n\n// TODO: parse the symbol from the storage key, or use a static client-side symbol map\nexport const mapToAsset = (apiInstance: ApiPromise) => ([_storageKey, codec]: [unknown, Codec]) => {\n    return {\n        id: (apiInstance.createType(\n                assetDataType,\n                codec\n            ).toHuman() as string)\n    } as Asset;\n        \n}\n\nexport const useGetAssets = () => {\n    const { apiInstance, loading } = usePolkadotJsContext();\n\n    return useCallback(async () => {\n        if (!apiInstance || loading) return;\n\n        // TODO: do we wanna order these by id?\n        return (await apiInstance?.query.assetRegistry.assetIds.entries())\n            .map(mapToAsset(apiInstance)) || [];\n    }, [\n        apiInstance,\n        loading\n    ]);\n}","export enum ChartGranularity {\n    // ALL = 'ALL',\n    D30 = 'D30',\n    D7 = 'D7',\n    H24 = 'H24',\n    H1 = 'H1'\n}\n\nexport enum ChartType {\n    PRICE = 'PRICE',\n    VOLUME = 'VOLUME',\n    WEIGHTS = 'WEIGHTS'\n}\n\n\nexport interface Asset {\n    symbol: string | undefined,\n    fullName: string | undefined\n    icon?: string | undefined\n}\n\nexport interface AssetPair {\n    assetA: Asset,\n    assetB: Asset | undefined\n}\n\nexport enum PoolType {\n    LBP = 'LBP',\n    XYK = 'XYK'\n}\n\n// Display data is not in the {x,y} format, since it solely represents\n// an amount in a given asset\nexport interface DisplayData {\n    balance: number | undefined,\n    usdBalance: number | undefined,\n    asset: Asset\n}","export type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = {\n  [K in keyof T]: T[K];\n};\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & {\n  [SubKey in K]?: Maybe<T[SubKey]>;\n};\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {\n  [SubKey in K]: Maybe<T[SubKey]>;\n};\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n};\n\nexport type Account = {\n  __typename?: 'Account';\n  balances: Array<Balance>;\n  id: Scalars['String'];\n  isActive: Scalars['Boolean'];\n  name?: Maybe<Scalars['String']>;\n  vestingSchedule: VestingSchedule;\n};\n\nexport type Asset = {\n  __typename?: 'Asset';\n  id: Scalars['String'];\n};\n\nexport type Balance = {\n  __typename?: 'Balance';\n  assetId: Scalars['String'];\n  balance: Scalars['String'];\n};\n\nexport type BuyActionDetail = {\n  __typename?: 'BuyActionDetail';\n  assetIn: Scalars['String'];\n  assetInAmount: Scalars['String'];\n  assetOut: Scalars['String'];\n  assetOutAmount: Scalars['String'];\n  buyPrice: Scalars['String'];\n  feeAmount: Scalars['String'];\n  feeAsset: Scalars['String'];\n  poolId: Scalars['String'];\n};\n\nexport type ClientUserAction = {\n  __typename?: 'ClientUserAction';\n  account: Scalars['String'];\n  action: UserActionType;\n  clientDetails?: Maybe<ClientUserActionDetail>;\n  detail?: Maybe<UserActionDetail>;\n  id: Scalars['String'];\n  status: Status;\n};\n\nexport type ClientUserActionDetail = {\n  __typename?: 'ClientUserActionDetail';\n  blockHeight?: Maybe<Scalars['String']>;\n  inBlockHash?: Maybe<Scalars['String']>;\n};\n\nexport type Config = {\n  __typename?: 'Config';\n  appName: Scalars['String'];\n  feePaymentAsset?: Maybe<Scalars['String']>;\n  nodeUrl: Scalars['String'];\n  processorUrl: Scalars['String'];\n};\n\nexport type Extension = {\n  __typename?: 'Extension';\n  isAvailable?: Maybe<Scalars['Boolean']>;\n};\n\nexport type Fee = {\n  __typename?: 'Fee';\n  denominator: Scalars['String'];\n  numerator: Scalars['String'];\n};\n\nexport type FeePaymentAsset = {\n  __typename?: 'FeePaymentAsset';\n  assetId?: Maybe<Scalars['String']>;\n  fallbackPrice?: Maybe<Scalars['String']>;\n};\n\nexport type LbpAssetWeights = {\n  __typename?: 'LBPAssetWeights';\n  current: Scalars['String'];\n  final: Scalars['String'];\n  initial: Scalars['String'];\n};\n\nexport type LbpPool = {\n  __typename?: 'LBPPool';\n  assetAWeights: LbpAssetWeights;\n  assetBWeights: LbpAssetWeights;\n  assetInId: Scalars['String'];\n  assetOutId: Scalars['String'];\n  balances?: Maybe<Array<Balance>>;\n  endBlock: Scalars['String'];\n  fee: Fee;\n  id: Scalars['String'];\n  repayTargetReached: Scalars['Boolean'];\n  startBlock: Scalars['String'];\n};\n\nexport type LastBlock = {\n  __typename?: 'LastBlock';\n  id: Scalars['String'];\n  parachainBlockNumber?: Maybe<Scalars['String']>;\n  relaychainBlockNumber?: Maybe<Scalars['String']>;\n};\n\nexport type Pool = LbpPool | XykPool;\n\nexport type Query = {\n  __typename?: 'Query';\n  _empty?: Maybe<Scalars['String']>;\n  _tradeType?: Maybe<TradeType>;\n  account?: Maybe<Account>;\n  accounts: Array<Account>;\n  action?: Maybe<ClientUserAction>;\n  actionLog: Array<ClientUserAction>;\n  assets?: Maybe<Array<Asset>>;\n  config: Config;\n  extension: Extension;\n  feePaymentAssets?: Maybe<Array<FeePaymentAsset>>;\n  lastBlock?: Maybe<LastBlock>;\n  pools?: Maybe<Array<Pool>>;\n  userActions: Array<UserAction>;\n};\n\nexport type SellActionDetail = {\n  __typename?: 'SellActionDetail';\n  assetIn: Scalars['String'];\n  assetInAmount: Scalars['String'];\n  assetOut: Scalars['String'];\n  assetOutAmount: Scalars['String'];\n  feeAmount: Scalars['String'];\n  feeAsset: Scalars['String'];\n  poolId: Scalars['String'];\n  sellPrice: Scalars['String'];\n};\n\nexport enum Status {\n  IsError = 'IsError',\n  IsReady = 'IsReady',\n  Unapproved = 'Unapproved',\n  IsBroadcast = 'isBroadcast',\n  IsFinalized = 'isFinalized',\n  IsInBlock = 'isInBlock',\n}\n\nexport enum TradeType {\n  Buy = 'Buy',\n  Sell = 'Sell',\n}\n\nexport type UserAction = {\n  __typename?: 'UserAction';\n  account: Scalars['String'];\n  action: UserActionType;\n  detail?: Maybe<UserActionDetail>;\n  id: Scalars['String'];\n  parachainBlockHeight?: Maybe<Scalars['String']>;\n  status: Status;\n};\n\nexport type UserActionDetail = BuyActionDetail | SellActionDetail;\n\nexport enum UserActionType {\n  AddLiquidity = 'AddLiquidity',\n  Buy = 'Buy',\n  RemoveLiquidity = 'RemoveLiquidity',\n  Sell = 'Sell',\n  SetFeeAsset = 'SetFeeAsset',\n  Transfer = 'Transfer',\n  Xcm = 'XCM',\n}\n\nexport type VestingSchedule = {\n  __typename?: 'VestingSchedule';\n  perPeriod?: Maybe<Scalars['String']>;\n  period?: Maybe<Scalars['String']>;\n  periodCount?: Maybe<Scalars['String']>;\n  remainingVestingAmount?: Maybe<Scalars['String']>;\n  start?: Maybe<Scalars['String']>;\n};\n\nexport type XykPool = {\n  __typename?: 'XYKPool';\n  assetInId: Scalars['String'];\n  assetOutId: Scalars['String'];\n  balances?: Maybe<Array<Balance>>;\n  id: Scalars['String'];\n};\n","import { ApolloCache } from '@apollo/client';\nimport { GetActiveAccountQueryResponse, GET_ACTIVE_ACCOUNT } from './queries/useGetActiveAccountQuery';\n\nexport const readActiveAccount = (\n    cache: ApolloCache<object>\n) => {\n    return cache.readQuery<GetActiveAccountQueryResponse>({\n        query: GET_ACTIVE_ACCOUNT,\n        /**\n         * TODO: if the active account query does not return all the queried data,\n         * such as vesting schedules (fields should be nullable, but they are simply not returned.\n         * Then the cache is incomplete and would return null/undefined, thats why we need to\n         * accept only partial data below.\n         */\n        returnPartialData: true,\n    })?.account\n}","import { ApolloCache } from '@apollo/client'\nimport { ApiPromise } from '@polkadot/api'\nimport { web3FromAddress } from '@polkadot/extension-dapp'\nimport { useCallback } from 'react'\nimport { readActiveAccount } from '../../accounts/readActiveAccount'\nimport { usePolkadotJsContext } from '../../polkadotJs/usePolkadotJs'\nimport { gracefulExtensionCancelationErrorHandler, reject, resolve, vestingClaimHandler, withGracefulErrors } from '../../vesting/useVestingMutationResolvers'\n\nexport const buyHandler = (resolve: resolve, reject: reject, apiInstance: ApiPromise) => {\n    return vestingClaimHandler(resolve, reject, apiInstance);\n}\n\nexport const buy = async (\n    cache: ApolloCache<object>,\n    apiInstance: ApiPromise,\n    assetBuy: string,\n    assetSell: string,\n    amountBuy: string,\n    maxSold: string,\n) => {\n    await withGracefulErrors(async (resolve, reject) => {\n        const activeAccount = readActiveAccount(cache);\n        const address = activeAccount?.id;\n\n        if (!address) return reject(new Error('No active account found'));\n\n        const { signer } = await web3FromAddress(address);\n        \n        await apiInstance.tx.lbp.buy(\n            assetBuy,\n            assetSell,\n            amountBuy,\n            maxSold\n        )\n            .signAndSend(\n                address,\n                { signer },\n                buyHandler(resolve, reject, apiInstance)\n            )\n    }, [\n        gracefulExtensionCancelationErrorHandler\n    ])\n}","import { ApolloCache } from '@apollo/client'\nimport { ApiPromise } from '@polkadot/api'\nimport { web3FromAddress } from '@polkadot/extension-dapp'\nimport { readActiveAccount } from '../../accounts/readActiveAccount'\nimport { gracefulExtensionCancelationErrorHandler, reject, resolve, vestingClaimHandler, withGracefulErrors } from '../../vesting/useVestingMutationResolvers'\n\nexport const sellHandler = (resolve: resolve, reject: reject, apiInstance: ApiPromise) => {\n    return vestingClaimHandler(resolve, reject, apiInstance);\n}\n\nexport const sell = async (\n    cache: ApolloCache<object>,\n    apiInstance: ApiPromise,\n    assetSell: string,\n    assetBuy: string,\n    amountSell: string,\n    minBought: string,\n) => {\n    await withGracefulErrors(async (resolve, reject) => {\n        const activeAccount = readActiveAccount(cache);\n        const address = activeAccount?.id;\n\n        if (!address) return reject(new Error('No active account found'));\n\n        const { signer } = await web3FromAddress(address);\n        \n        await apiInstance.tx.lbp.sell(\n            assetSell,\n            assetBuy,\n            amountSell,\n            minBought\n        )\n            .signAndSend(\n                address,\n                { signer },\n                sellHandler(resolve, reject, apiInstance)\n            )\n    }, [\n        gracefulExtensionCancelationErrorHandler\n    ])\n}","import { useQuery } from '@apollo/client';\nimport { loader } from 'graphql.macro';\nimport { Query } from '../../../generated/graphql';\n\nexport const GET_ACTION_LOG = loader('../graphql/GetActionLog.query.graphql');\n\nexport interface GetActionLogQueryResponse {\n  actionLog: Query['actionLog'];\n}\n\nexport const useGetActionLogQuery = () =>\n  useQuery<GetActionLogQueryResponse>(GET_ACTION_LOG, {\n    notifyOnNetworkStatusChange: true,\n    returnPartialData: true,\n  });\n","import { ApolloCache } from '@apollo/client';\nimport {\n  GetActionLogQueryResponse,\n  GET_ACTION_LOG,\n} from '../queries/useGetActionLogQuery';\n\nexport const readActionLog = (cache: ApolloCache<object>) => {\n  return cache.readQuery<GetActionLogQueryResponse>({\n    query: GET_ACTION_LOG,\n    returnPartialData: true,\n  })?.actionLog;\n};\n","import { ApolloCache } from '@apollo/client';\nimport { readActionLog } from './readActionLog';\n\nimport { find } from 'lodash';\n\nexport const readUserAction = (id: string, cache: ApolloCache<object>) => {\n  const actions = readActionLog(cache) || [];\n  return find(actions, { id: id });\n};\n","import { useCallback } from 'react';\nimport { ClientUserAction } from '../../../generated/graphql';\nimport { useResolverToRef } from '../../accounts/resolvers/useAccountsMutationResolvers';\nimport { ApolloCache, NormalizedCacheObject } from '@apollo/client';\nimport { readActionLog } from '../helpers/readActionLog';\nimport { readUserAction } from '../helpers/readUserAction';\nimport { GetUserActionByIdQueryVariables } from '../queries/useGetUserActionByIDQuery';\n\nexport const __typename: ClientUserAction['__typename'] = 'ClientUserAction';\n\nexport const useGetActionLogQueryResolver = () => {\n  return useResolverToRef(\n    useCallback(\n      async (\n        { cache }: { cache: ApolloCache<NormalizedCacheObject> },\n        args?: GetUserActionByIdQueryVariables\n      ) => {\n        if (args) {\n          return readUserAction(args.id, cache);\n        }\n        return readActionLog(cache);\n      },\n      []\n    ),\n    'actionLog'\n  );\n};\n","import { ApolloCache } from '@apollo/client';\nimport {\n  GetActionLogQueryResponse,\n  GET_ACTION_LOG,\n} from '../queries/useGetActionLogQuery';\nimport { readActionLog } from './readActionLog';\nimport { ClientUserAction } from '../../../generated/graphql';\nimport { __typename } from '../resolvers/useGetActionLogQueryResolver';\nimport log from 'loglevel';\n\nexport const addAction = (\n  cache: ApolloCache<object>,\n  item: ClientUserAction\n) => {\n  const current = readActionLog(cache) || [];\n\n  log.debug(\n    `UserAction: add user action ${item.action} (${item.id} - ${item.status})`\n  );\n\n  return cache.writeQuery<GetActionLogQueryResponse>({\n    query: GET_ACTION_LOG,\n    data: {\n      actionLog: [...current, { ...item, __typename }],\n    },\n  });\n};\n","import { ApolloCache } from '@apollo/client';\nimport { Status } from '../../../generated/graphql';\nimport { __typename } from '../resolvers/useGetActionLogQueryResolver';\nimport { readUserAction } from './readUserAction';\nimport { addAction } from './addAction';\nimport log from 'loglevel';\n\nexport const updateUserAction = (\n  cache: ApolloCache<object>,\n  id: string,\n  status?: Status,\n  inBlockHash?: string\n) => {\n  cache.modify({\n    id: cache.identify({ id: id, __typename }),\n    fields: {\n      status(s) {\n        if (status) {\n          log.debug(`UserAction: updating action status ${status} (${id})`);\n          return status;\n        }\n        return s;\n      },\n      clientDetails(details) {\n        if (inBlockHash) {\n          log.debug(\n            `UserAction: updating action in block hash ${inBlockHash} (${id})`\n          );\n          return { ...details, inBlockHash: inBlockHash };\n        }\n        return details;\n      },\n    },\n  });\n};\n\nexport const updateUserActionId = (\n  cache: ApolloCache<object>,\n  id: string,\n  newId: string\n) => {\n  // Note: just modifying ID was not good enough - for some reason, it removed the item from cache\n  // That's why we remove and add new entry with new id\n  let entry = readUserAction(id, cache);\n  if (!entry) {\n    return;\n  }\n\n  log.debug(`UserAction: setting final user action id ${newId} (${id})`);\n\n  cache.evict({ id: cache.identify({ id: id, __typename }) });\n\n  addAction(cache, { ...entry, id: newId, __typename });\n};\n","import { ExtrinsicStatus } from '@polkadot/types/interfaces/author';\nimport { DispatchError, EventRecord } from '@polkadot/types/interfaces/system';\nimport log from 'loglevel';\nimport { ApolloCache, NormalizedCacheObject } from '@apollo/client';\nimport { ApiPromise } from '@polkadot/api';\nimport { Status, ClientUserAction } from '../../generated/graphql';\nimport {\n  updateUserAction,\n  updateUserActionId,\n} from './helpers/updateUserAction';\nimport { addAction } from './helpers/addAction';\nimport { findIndex, find } from 'lodash';\nimport { readLastBlock } from '../lastBlock/readLastBlock';\nimport { readUserAction } from './helpers/readUserAction';\n\nconst isOk = (api: ApiPromise, events: EventRecord[]) => {\n  const errorEvent = find(events, (event) =>\n    api.events.system.ExtrinsicFailed.is(event.event)\n  );\n\n  if (!errorEvent) {\n    const isOk = find(events, (event) =>\n      api.events.system.ExtrinsicSuccess.is(event.event)\n    );\n\n    return { result: isOk !== undefined, reason: undefined };\n  } else {\n    // TODO: find error and better error reason?\n    const [dispatchError] = errorEvent.event.data;\n\n    const errorInfo = dispatchError.toString();\n\n    log.error(\n      `UserAction: ${errorEvent.event.section}.${errorEvent.event.method}:: ExtrinsicFailed:: ${errorInfo}`\n    );\n    return { result: false, reason: errorInfo };\n  }\n};\n\n/**\n * Formats the event id into a fixed-length string. When formatted the natural string ordering\n * is the same as the ordering\n * in the blockchain (first ordered by block height, then by block ID)\n *\n * @return  id in the format 000000..00<blockNum>-000<index>-<shorthash>\n *\n */\nconst formatId = (height: string, index: number | undefined, hash: string) => {\n  const BLOCK_PAD_LENGTH = 10;\n  const INDEX_PAD_LENGTH = 6;\n  const HASH_PAD_LENGTH = 5;\n\n  const blockPart = `${String(height).padStart(BLOCK_PAD_LENGTH, '0')}`;\n  const indexPart =\n    index !== undefined\n      ? `-${String(index).padStart(INDEX_PAD_LENGTH, '0')}`\n      : '';\n  const _hash = hash.startsWith('0x') ? hash.substring(2) : hash;\n  const shortHash =\n    _hash.length < HASH_PAD_LENGTH\n      ? _hash.padEnd(HASH_PAD_LENGTH, '0')\n      : _hash.slice(0, HASH_PAD_LENGTH);\n  return `${blockPart}${indexPart}-${shortHash}`;\n};\n\n/**\n * Run an async function and handle the thrown errors\n * with an array of error handlers, which may handle the errors gracefully\n *\n * @param fn\n * @param errorHandlers\n * @returns\n */\nexport type resolve = (result?: any) => void;\nexport type reject = (error?: any) => void;\n\nexport const withGracefulErrors = async (\n  fn: (resolve: resolve, reject: reject) => Promise<any>,\n  errorHandlers: ((error: any) => void)[]\n) => {\n  return new Promise<any>(async (resolve, reject) => {\n    try {\n      resolve(await fn(resolve, reject));\n    } catch (e: any) {\n      log.error('graceful error', e);\n      let ex = errorHandlers.reduce((e, errorHandler) => errorHandler(e), e);\n      // rejecting this promise with an error instead of throwing an error\n      // is necessary to reflect the apollo resolver loading state correctly\n      e ? reject(ex) : resolve(null);\n    }\n  });\n};\n\nexport const cancelledErrorMessage = 'Cancelled';\n\n/**\n * This is an example graceful error handler,\n * if this would return `e` instead of `void`,\n * then the following graceful error handler would be triggered,\n * or by default the error would be thrown.\n *\n * @param e\n * @returns\n */\nexport const gracefulExtensionCancelationErrorHandler = (e: any) => {\n  if ((e as Error)?.message === cancelledErrorMessage) {\n    log.error(\n      'Operation presumably cancelled by the user in the Polkadot.js extension'\n    );\n    return;\n  }\n  return e;\n};\n\nexport const handleTransactionStatus =\n  (\n    resolve: resolve,\n    reject: reject,\n    api: ApiPromise,\n    cache: ApolloCache<NormalizedCacheObject>,\n    txData: () => ClientUserAction\n  ) =>\n  async ({\n    status,\n    events = [],\n    dispatchError,\n  }: {\n    status: ExtrinsicStatus;\n    events: EventRecord[];\n    dispatchError?: DispatchError;\n  }) => {\n    if (status.isReady) {\n      // At this point, it is not yet in the action log cache\n      const lastBlockData = readLastBlock(cache);\n      addAction(cache, {\n        ...txData(),\n        status: Status.IsReady,\n        clientDetails: {\n          blockHeight: lastBlockData?.lastBlock?.parachainBlockNumber,\n          inBlockHash: undefined,\n        },\n      });\n    }\n\n    if (status.isBroadcast) {\n      updateUserAction(cache, txData().id, Status.IsBroadcast);\n    }\n\n    if (status.isInBlock) {\n      const { result: isSuccess, reason: errorReason } = isOk(api, events);\n\n      if (isSuccess) {\n        updateUserAction(\n          cache,\n          txData().id,\n          Status.IsInBlock,\n          status.asInBlock.hash.toHex()\n        );\n      } else {\n        //TODO: do something with error reason\n        log.error(errorReason);\n        updateUserAction(cache, txData().id, Status.IsError);\n      }\n    }\n    if (status.isFinalized) {\n      updateUserAction(cache, txData().id, Status.IsFinalized);\n\n      const userAction = readUserAction(txData().id, cache);\n\n      // If inBlockHash does not match finalized hash,\n      // It was finalized in another block\n      // Need to check if extrinsic is success again\n      let txSuccess = true;\n      if (\n        userAction?.clientDetails?.inBlockHash !==\n        status.asFinalized.hash.toHex()\n      ) {\n        log.debug(\n          'UserAction: checking ExtrinsicSuccess after IsFinalized due to InBlock Hash mismatch'\n        );\n\n        const { result: isSuccess, reason: errorReason } = isOk(api, events);\n\n        txSuccess = isSuccess;\n        if (!isSuccess) {\n          //TODO: do something with error reason\n          updateUserAction(cache, txData().id, Status.IsError);\n        } else {\n          log.error(errorReason);\n        }\n      }\n\n      if (txSuccess) {\n        const blockHash = status.asFinalized.toHex();\n        const signedBlock = await api.rpc.chain.getBlock(blockHash);\n        const paraChainBlockHeight = signedBlock.block.header.number.toString();\n\n        const txHash = txData().id;\n\n        let txBlockIndex = findIndex(\n          signedBlock.block.extrinsics,\n          (ex) => ex.hash.toHex() === txHash\n        );\n\n        if (txBlockIndex === -1) {\n          //TODO: WHAT DO?\n          log.warn('UserAction: Transaction index not found in block ', txHash);\n          return;\n        }\n\n        const txId = formatId(paraChainBlockHeight, txBlockIndex, blockHash);\n\n        updateUserActionId(cache, txData().id, txId);\n      }\n    }\n  };\n","import { ApolloCache, NormalizedCacheObject } from '@apollo/client';\nimport { ApiPromise } from '@polkadot/api';\nimport { web3FromAddress } from '@polkadot/extension-dapp';\nimport { readActiveAccount } from '../../accounts/readActiveAccount';\nimport {\n  gracefulExtensionCancelationErrorHandler,\n  handleTransactionStatus,\n  withGracefulErrors,\n} from '../../actionLog/handleTransactionStatus';\nimport { Status, UserActionType } from '../../../generated/graphql';\n\nexport const discount = false;\n\nexport const buy = async (\n  cache: ApolloCache<NormalizedCacheObject>,\n  apiInstance: ApiPromise,\n  assetBuy: string, // 1\n  assetSell: string, // 49.7 + 0.2% = 49.9\n  amountBuy: string, // 99\n  maxSold: string // 49.5 + 0.5%\n) => {\n  await withGracefulErrors(\n    async (resolve, reject) => {\n      const activeAccount = readActiveAccount(cache);\n      const address = activeAccount?.id;\n\n      if (!address) return reject(new Error('No active account found!'));\n\n      const { signer } = await web3FromAddress(address);\n\n      const call = apiInstance.tx.xyk.buy(\n        assetBuy,\n        assetSell,\n        amountBuy,\n        maxSold,\n        discount\n      );\n\n      await call.signAndSend(\n        address,\n        { signer },\n        handleTransactionStatus(resolve, reject, apiInstance, cache, () => {\n          return {\n            id: call.hash.toHex(),\n            account: address,\n            action: UserActionType.Buy,\n            status: Status.Unapproved,\n          };\n        })\n      );\n    },\n    [gracefulExtensionCancelationErrorHandler]\n  );\n};\n","import { ApolloCache, NormalizedCacheObject } from '@apollo/client';\nimport { ApiPromise } from '@polkadot/api';\nimport { web3FromAddress } from '@polkadot/extension-dapp';\nimport { readActiveAccount } from '../../accounts/readActiveAccount';\nimport {\n  gracefulExtensionCancelationErrorHandler,\n  handleTransactionStatus,\n  withGracefulErrors,\n} from '../../actionLog/handleTransactionStatus';\nimport { Status, UserActionType } from '../../../generated/graphql';\n\nexport const discount = false;\n\nexport const sell = async (\n  cache: ApolloCache<NormalizedCacheObject>,\n  apiInstance: ApiPromise,\n  assetSell: string,\n  assetBuy: string,\n  amountSell: string,\n  minBought: string\n) => {\n  await withGracefulErrors(\n    async (resolve, reject) => {\n      const activeAccount = readActiveAccount(cache);\n      const address = activeAccount?.id;\n\n      if (!address) return reject(new Error('No active account found!'));\n\n      const { signer } = await web3FromAddress(address);\n\n      const call = apiInstance.tx.xyk.sell(\n        assetSell,\n        assetBuy,\n        amountSell,\n        minBought,\n        discount\n      );\n\n      await call.signAndSend(\n        address,\n        { signer },\n        handleTransactionStatus(resolve, reject, apiInstance, cache, () => {\n          return {\n            id: call.hash.toString(),\n            account: address,\n            action: UserActionType.Sell,\n            status: Status.Unapproved,\n          };\n        })\n      );\n    },\n    [gracefulExtensionCancelationErrorHandler]\n  );\n};\n","import { useSubmitTradeMutationResolver } from './useSubmitTradeMutationResolvers'\n\nexport const usePoolsMutationResolvers = () => {\n    const submitTrade = useSubmitTradeMutationResolver();\n    \n    return {\n        submitTrade\n    }\n}","import { ApolloCache, NormalizedCacheObject } from '@apollo/client';\nimport BigNumber from 'bignumber.js';\nimport { gql } from 'graphql.macro';\nimport { useCallback } from 'react'\nimport { PoolType } from '../../../components/Chart/shared';\nimport { Maybe, TradeType } from '../../../generated/graphql';\nimport { useResolverToRef } from '../../accounts/resolvers/useAccountsMutationResolvers'\nimport { usePolkadotJsContext } from '../../polkadotJs/usePolkadotJs';\nimport { SubmitTradeMutationVariables } from '../mutations/useSubmitTradeMutation';\nimport { buy as buyLbp } from '../lbp/buy';\nimport { sell as sellLbp } from '../lbp/sell';\nimport { buy as buyXyk } from '../xyk/buy'\nimport { sell as sellXyk } from '../xyk/sell';\n\n// this is for buy, for sell we need to use minus, not plus\nexport const applyAllowedSlippage = (\n    amount: string, \n    allowedSlippage: string,\n    tradeType: TradeType\n) => {\n    let slippageAmount = new BigNumber(amount)\n        .multipliedBy(\n            new BigNumber(allowedSlippage)\n                .dividedBy(100)\n        )\n\n    const amountBN = new BigNumber(amount);\n    \n    const amountWithSlippage = tradeType === TradeType.Buy\n            // if you're buying an exact amount,\n            // you must be willing to pay more\n            ? amountBN.plus(slippageAmount)\n            // if you're selling an exact amount,\n            // you should be willing to receive less\n            : amountBN.minus(slippageAmount)\n    \n    return amountWithSlippage.toFixed(0);\n}\n\nexport const applyTradeFee = (\n    amount: string,\n    // TODO: get this from constants\n    tradeFee: string = '0.002', // 0.2% default\n    tradeType: TradeType\n) => {\n    let fee = new BigNumber(amount)\n        .multipliedBy(\n            new BigNumber(tradeFee)\n        )\n\n    const amountBN = new BigNumber(amount);\n    \n    const amountWithFee = tradeType === TradeType.Buy\n            ? amountBN.plus(fee)\n            : amountBN.minus(fee);\n            \n    return amountWithFee.toFixed(0);\n}\n\nexport const useSubmitTradeMutationResolver = () => {\n    const { apiInstance } = usePolkadotJsContext();\n\n    return useResolverToRef(\n        useCallback(async (\n            _obj,\n            args: Maybe<SubmitTradeMutationVariables>,\n            { cache }: { cache: ApolloCache<NormalizedCacheObject> }\n        ) => {\n            if (!args || !apiInstance) return\n            if (args?.poolType === PoolType.XYK && args?.tradeType === TradeType.Buy) {\n                return await buyXyk(\n                    cache,\n                    apiInstance,\n                    args.assetOutId,\n                    args.assetInId,\n                    args.assetOutAmount,\n                    args.amountWithSlippage,\n                );\n            }\n\n            if (args?.poolType === PoolType.XYK && args?.tradeType === TradeType.Sell) {\n                return await sellXyk(\n                    cache,\n                    apiInstance,\n                    args.assetInId,\n                    args.assetOutId,\n                    args.assetInAmount,\n                    args.amountWithSlippage,\n                );\n            }\n\n            if (args?.poolType === PoolType.LBP && args?.tradeType === TradeType.Buy) {\n                return await buyLbp(\n                    cache,\n                    apiInstance,\n                    args.assetOutId,\n                    args.assetInId,\n                    args.assetOutAmount,\n                    args.amountWithSlippage\n                )\n            }\n\n            if (args?.poolType === PoolType.LBP && args?.tradeType === TradeType.Sell) {\n                return await sellLbp(\n                    cache,\n                    apiInstance,\n                    args.assetOutId,\n                    args.assetInId,\n                    args.assetOutAmount,\n                    args.amountWithSlippage\n                )\n            }\n\n            throw new Error('We dont support this trade type yet');\n        }, [buyXyk, sellXyk, apiInstance])\n    )\n}","import { useGetActionLogQueryResolver } from './resolvers/useGetActionLogQueryResolver';\n\nexport const useActionLogQueryResolvers = () => {\n  const getActionLogQueryResolver = useGetActionLogQueryResolver();\n\n  return {\n    actionLog: getActionLogQueryResolver,\n  };\n};\n","import { useMemo } from 'react';\nimport { ApolloClient, InMemoryCache, Resolvers } from '@apollo/client';\nimport { useAccountsQueryResolvers } from '../accounts/resolvers/useAccountsQueryResolvers';\nimport { loader } from 'graphql.macro';\nimport { persistCache, LocalStorageWrapper } from 'apollo3-cache-persist';\nimport { useAccountsMutationResolvers } from '../accounts/resolvers/useAccountsMutationResolvers';\nimport { useRefetchWithNewBlock } from '../lastBlock/useRefetchWithNewBlock';\nimport { usePersistentConfig } from '../config/usePersistentConfig';\nimport { useVestingMutationResolvers } from '../vesting/useVestingMutationResolvers';\n\nimport { useBalanceMutationResolvers } from '../balances/useBalanceMutationResolvers';\nimport { useExtensionQueryResolvers } from '../polkadotJs/useExtensionQueryResolvers';\nimport { useConfigQueryResolvers } from '../config/useConfigQueryResolvers';\nimport { useConfigMutationResolvers } from '../config/useConfigMutationResolver';\nimport { useFeePaymentAssetsQueryResolvers } from '../feePaymentAssets/useFeePaymentAssetsQueryResolvers';\nimport { usePoolsQueryResolver } from '../pools/resolvers/usePoolsQueryResolver';\nimport { useBalanceQueryResolvers } from '../balances/useBalanceQueryResolvers';\nimport { useAssetsQueryResolvers } from '../assets/resolvers/useAssetsQueryResolvers';\nimport { usePoolsMutationResolvers } from '../pools/resolvers/usePoolsMutationResolvers';\nimport { useActionLogQueryResolvers } from '../actionLog/useActionQueryResolvers';\n\n/**\n * Add all local gql resolvers here\n * @returns Resolvers\n */\nexport const useResolvers: () => Resolvers = () => {\n  const { Query: AccountsQueryResolver, Account } = useAccountsQueryResolvers();\n  const {\n    Query: PoolsQueryResolver,\n    XYKPool,\n    LBPPool,\n  } = usePoolsQueryResolver();\n  return {\n    Query: {\n      ...AccountsQueryResolver,\n      ...useExtensionQueryResolvers(),\n      ...useConfigQueryResolvers(),\n      ...useFeePaymentAssetsQueryResolvers(),\n      ...useBalanceQueryResolvers(),\n      ...PoolsQueryResolver,\n      ...useAssetsQueryResolvers(),\n      ...useActionLogQueryResolvers(),\n    },\n    Mutation: {\n      ...useAccountsMutationResolvers(),\n      ...useVestingMutationResolvers(),\n      ...useBalanceMutationResolvers(),\n      ...useConfigMutationResolvers(),\n      ...usePoolsMutationResolvers(),\n    },\n    Account,\n    XYKPool,\n    LBPPool,\n  };\n};\n\nexport const typeDefs = loader('./../../schema.graphql');\n\n/**\n * Recreates the apollo client instance each time the config changes\n * @returns\n */\nexport const useConfigureApolloClient = () => {\n  const resolvers = useResolvers();\n  // can't get the config from a query before we setup apollo\n  // therefore we get it from the local storage instead\n  const [{ processorUrl }] = usePersistentConfig();\n\n  const cache = useMemo(() => {\n    const inMemoryCache = new InMemoryCache();\n    persistCache({\n      cache: inMemoryCache,\n      storage: new LocalStorageWrapper(window.localStorage),\n    }).then(() => {\n      //TODO: what do ?\n    });\n    return inMemoryCache;\n  }, []);\n\n  const client = useMemo(() => {\n    return new ApolloClient({\n      uri: processorUrl,\n      cache,\n      // TODO: don't connect in production\n      connectToDevTools: true,\n      queryDeduplication: true,\n      resolvers,\n      typeDefs,\n    });\n  }, [resolvers, processorUrl, cache]);\n\n  useRefetchWithNewBlock(client);\n\n  return client;\n};\n\nexport const useApollo = () => useConfigureApolloClient();\n","import { Resolver } from '@apollo/client';\nimport { useCallback } from 'react';\nimport { useBalanceQueryResolvers } from '../../balances/useBalanceQueryResolvers';\nimport { useResolverToRef } from './useAccountsMutationResolvers';\nimport { useVestingScheduleQueryResolvers } from '../../vesting/useVestingScheduleQueryResolvers';\nimport { useGetAccountsQueryResolver } from './useGetAccountsQueryResolver';\n\n/**\n * Used to resolve queries for the `Account` (or `accounts`) entity.\n */\nexport const useAccountsQueryResolvers = () => {    \n    const getAccountsQueryResolver = useGetAccountsQueryResolver();\n\n    return {\n        Query: {\n            accounts: getAccountsQueryResolver\n        },\n        /**\n         * Additional sub-resolvers for the `Account` entity,\n         * resolving e.g. the `balances` or `vestingSchedules` fields.\n         */\n        Account: {\n            ...useBalanceQueryResolvers(),\n            ...useVestingScheduleQueryResolvers()\n        }\n    }\n}","import { useBalanceQueryResolvers } from '../../balances/useBalanceQueryResolvers'\nimport { useGetPoolsQueryResolver } from './useGetPoolsQueryResolver'\n\nexport const usePoolsQueryResolver = () => {\n    const getPoolsQueryResolver = useGetPoolsQueryResolver()\n    const poolFieldsQueryResolvers = {\n        ...useBalanceQueryResolvers()\n    }\n\n    return {\n        Query: {\n            pools: getPoolsQueryResolver,\n        },\n        XYKPool: poolFieldsQueryResolvers,\n        LBPPool: poolFieldsQueryResolvers\n    }\n}","import { useGetAssetsQueryResolver } from './useGetAssetsQueryResolver'\n\nexport const useAssetsQueryResolvers = () => {\n    const getAssetsQueryResolver = useGetAssetsQueryResolver();\n\n    return {\n        assets: getAssetsQueryResolver\n        // TODO: add stuff like a total circulating supply or other data we might need\n        // Asset:\n    }\n}","import { useLazyQuery, useQuery } from '@apollo/client';\nimport constate from 'constate';\nimport { loader } from 'graphql.macro';\nimport { Query } from '../../generated/graphql';\n\nexport const GET_EXTENSION = loader('./graphql/GetExtension.query.graphql');\n\nexport interface GetExtensionQueryResponse {\n    extension: Query['extension']\n}\n\nexport const useGetExtensionQuery = () => useQuery<GetExtensionQueryResponse>(GET_EXTENSION, {\n    notifyOnNetworkStatusChange: true,\n});\n\nexport const useGetExtensionLazyQuery = () => useLazyQuery<GetExtensionQueryResponse>(GET_EXTENSION, {\n    notifyOnNetworkStatusChange: true\n})\n\nexport const [GetExtensionQueryProvider, useContextualGetExtensionLazyQuery] = constate(useGetExtensionLazyQuery);","import { ApolloProvider, useApolloClient } from '@apollo/client';\nimport React from 'react';\nimport { GetActiveAccountQueryProvider } from '../hooks/accounts/queries/useGetActiveAccountQuery';\nimport { useConfigureApolloClient } from '../hooks/apollo/useApollo';\nimport { LastBlockProvider } from '../hooks/lastBlock/useSubscribeNewBlockNumber';\nimport { GetExtensionQueryProvider } from '../hooks/polkadotJs/useGetExtensionQuery';\nimport { PolkadotJsProvider } from '../hooks/polkadotJs/usePolkadotJs';\nimport { MathProvider } from '../hooks/math/useMath';\n\nexport const ConfiguredApolloProvider = ({ children }: { children: React.ReactNode }) => {\n    const client = useConfigureApolloClient();\n    return (\n        <ApolloProvider client={client}>\n            {children}\n        </ApolloProvider>\n    )\n}\n\nexport const QueryProvider = ({ children }: { children: React.ReactNode }) => (\n    <GetExtensionQueryProvider>\n        {children}\n    </GetExtensionQueryProvider>\n)\n\n// TODO: use react-multi-provider instead of ugly nesting\nexport const MultiProvider = ({ children }: { children: React.ReactNode }) => {\n    return (\n        <PolkadotJsProvider>\n            <MathProvider>\n                <LastBlockProvider>\n                    <ConfiguredApolloProvider>\n                        <QueryProvider>\n                            {children}\n                        </QueryProvider>\n                    </ConfiguredApolloProvider>\n                </LastBlockProvider>\n            </MathProvider>\n        </PolkadotJsProvider>\n\n    )\n}","import { useQuery } from '@apollo/client';\nimport { loader } from 'graphql.macro';\nimport { Pool } from '../../../generated/graphql';\nimport { GetPoolsQueryResponse } from './useGetPoolsQuery';\n\nexport const GET_POOL_BY_ASSETS = loader('./../graphql/GetPoolByAssets.query.graphql');\n\nexport interface GetPoolByAssetsQueryVariables {\n    assetInId?: string,\n    assetOutId?: string,\n}\nexport interface GetPoolQueryResponse {\n    pool: Pool\n}\n\nexport const useGetPoolByAssetsQuery = (variables: GetPoolByAssetsQueryVariables) => useQuery<GetPoolQueryResponse>(\n    GET_POOL_BY_ASSETS, \n    { \n        variables,\n        notifyOnNetworkStatusChange: true,\n    }\n);","import { useMemo } from 'react'\nimport { UseFormReturn } from 'react-hook-form'\n\nexport interface TokenInputProps {\n    assetIdInputProps: object,\n    assetAmountInputProps: object,\n    disabled?: boolean\n}\n\nexport const TokenInput = ({\n    assetIdInputProps,\n    assetAmountInputProps,\n    disabled\n}: TokenInputProps) => {\n    return <div>\n        <div>\n            <b>AssetId:</b> <br/>\n            <input\n                disabled={disabled}\n                type='text' \n                {...assetIdInputProps} \n            />\n        </div>\n        <div>\n            <b>Asset amount:</b> <br/>\n            <input\n                disabled={disabled}\n                type='text' \n                {...assetAmountInputProps}\n            />\n        </div>\n    </div>\n}","import BigNumber from 'bignumber.js';\nimport { useMemo } from 'react';\n\nexport const PRECISION_12 = 12;\nexport const PRECISION_18 = 18;\nexport const precision12 = new BigNumber(10).pow(PRECISION_12);\nexport const precision18 = new BigNumber(10).pow(PRECISION_18);\n\nexport const fromPrecision12 = (amount?: string | BigNumber) => (\n    amount && new BigNumber(amount)\n        .dividedBy(precision12).toFixed(PRECISION_12)\n)\nexport const useFromPrecision12 = (amount?: string | BigNumber) => (\n    useMemo(() => fromPrecision12(amount), [amount])\n)\n\nexport const useFromPrecision18 = (amount?: string | BigNumber) => (\n    useMemo(() => (\n        amount && new BigNumber(amount)\n            .dividedBy(precision18).toFixed(PRECISION_18)\n    ), [amount])\n)","import BigNumber from 'bignumber.js';\nimport { useMemo } from 'react';\nimport { PRECISION_12 } from './useFromPrecision';\n\nexport const PRECISION_0 = 0;\nexport const precision12 = new BigNumber(10).pow(12);\nexport const precision18 = new BigNumber(10).pow(18);\n\nexport const toPrecision12 = (amount?: string | BigNumber) => (\n    amount && new BigNumber(amount)\n            .multipliedBy(precision12).toFixed(PRECISION_0)\n);\nexport const useToPrecision12 = (amount?: string | BigNumber) => (\n    useMemo(() => toPrecision12(amount), [amount])\n)\n\nexport const useToPrecision18 = (amount?: string | BigNumber) => (\n    useMemo(() => (\n        amount && new BigNumber(amount)\n            .multipliedBy(precision18).toFixed(PRECISION_0)\n    ), [amount])\n)","import { useForm } from 'react-hook-form'\nimport { TradeFormProps } from '../TradeForm'\n\nexport interface TradeFormFields {\n    assetInId: string,\n    assetOutId?: string,\n    assetInAmount?: string,\n    assetOutAmount?: string,\n    allowedSlippage: string,\n    autoSlippage: boolean,\n}\n\n\n/**\n * Define fields for the TradeForm\n * @param param0 \n * @returns \n */\n export const useTradeForm = ({ assetInId, assetOutId }: TradeFormProps['assetIds']) => {\n    return useForm<TradeFormFields>({\n        defaultValues: {\n            assetInId,\n            assetOutId,\n            assetInAmount: '0',\n            assetOutAmount: '0',\n            allowedSlippage: '5',\n            autoSlippage: true,\n        }\n    })\n}","// TODO: revisit, this is very hacky, possibly a memory leak because the event handlers are not removed\n\nimport { useEffect, useState } from 'react';\nimport { UseFormReturn } from 'react-hook-form';\nimport { TradeFormFields } from './useTradeForm';\n\n/**\n * Trigger a state update each time the given input changes (via the `input` event)\n * @param form \n * @param field \n * @returns \n */\n export const useListenForInput = (form: UseFormReturn<TradeFormFields>, field: string) => {\n    const [state, setState] = useState<boolean>(false);\n    \n    const inputRef = (form.control._fields[field] as any)?._f?.ref;\n\n    useEffect(() => {\n        if (!inputRef) return;\n        const listener = inputRef\n            ?.addEventListener('input', () => setState(state => !state));\n        \n        return () => inputRef?.removeEventListener('input', listener);\n    }, [inputRef])\n\n    return state;\n}","import { useMutation } from '@apollo/client';\nimport { loader } from 'graphql.macro';\nimport { PoolType } from '../../../components/Chart/shared';\nimport { TradeType } from '../../../generated/graphql';\n\nconst SUBMIT_TRADE = loader('./../graphql/SubmitTrade.mutation.graphql');\n\nexport interface SubmitTradeMutationVariables {\n    assetInId: string,\n    assetOutId: string,\n    assetInAmount: string,\n    assetOutAmount: string,\n    poolType: PoolType,\n    tradeType: TradeType,\n    amountWithSlippage: string\n}\n\nexport const useSubmitTradeMutation = () => useMutation<void, SubmitTradeMutationVariables>(\n    SUBMIT_TRADE, \n    {\n        notifyOnNetworkStatusChange: true\n    }\n)\n\n/**\n * lbp.buy(assetOut, assetIn, amount, maxLimit)\n * lbp.sell(assetIn, assetOut, amount, maxLimit)\n * \n * exchange.buy(assetBuy, assetSell, amountBuy, maxSold, discount)\n * exchange.sell(assetSell, assetBuy, amountSell, minBought, discount)\n */\n\n","import log from 'loglevel';\nimport { useCallback } from 'react';\nimport { UseFormReturn } from 'react-hook-form';\nimport { PoolType } from '../../../components/Chart/shared';\nimport { TradeType } from '../../../generated/graphql';\nimport { toPrecision12 } from '../../../hooks/math/useToPrecision';\nimport { useSubmitTradeMutation } from '../../../hooks/pools/mutations/useSubmitTradeMutation';\nimport { applyAllowedSlippage } from '../../../hooks/pools/resolvers/useSubmitTradeMutationResolvers';\nimport { SpotPrice } from '../../../pages/TradePage/TradePage';\nimport { TradeFormProps } from '../TradeForm';\nimport { Slippage } from './useSlippage';\nimport { TradeFormFields } from './useTradeForm';\n\n/**\n * Submit the trade mutation once the trade form has been submitted\n * @param tradeType\n * @param pool \n * @returns \n */\n export const useHandleSubmit = (\n    tradeType: TradeType,\n    allowedSlippage: string,\n    slippage?: Slippage,\n    pool?: TradeFormProps['pool'],\n\n) => {\n    const [submitTrade] = useSubmitTradeMutation();\n    return useCallback(({\n        assetInId,\n        assetOutId,\n        assetInAmount,\n        assetOutAmount\n    }: TradeFormFields) => {\n        if (!pool) throw new Error(`Can't submit a trade mutation without a pool`);\n\n        assetInAmount = toPrecision12(assetInAmount);\n        assetOutAmount = toPrecision12(assetOutAmount);\n\n        if (!assetInId || !assetOutId || !assetInAmount || !assetOutAmount || !slippage?.spotPriceAmount) {\n            throw new Error(`Can't submit a trade mutation without all the required arguments`)\n        }\n\n        const amountWithSlippage = applyAllowedSlippage(\n            slippage?.spotPriceAmount,\n            allowedSlippage,\n            tradeType\n        );\n\n        log.debug('TradeForm.useHandleSubmit', 'amountWithSlippage', {\n            spotPriceAmount: slippage.spotPriceAmount,\n            amountWithSlippage,\n            tradeType\n        });\n\n        const poolType = pool.__typename === 'LBPPool'\n            ? PoolType.LBP\n            : PoolType.XYK\n\n        // Submit a trade with the given parameters to be handled by Apollo\n        submitTrade({ variables: {\n            tradeType,\n            assetInId,\n            assetInAmount,\n            assetOutId,\n            assetOutAmount,\n            amountWithSlippage,\n            poolType,\n        }});\n\n    }, [submitTrade, pool, tradeType, slippage]);\n}","import { find } from 'lodash';\nimport { XykPool } from '../../../generated/graphql';\nimport { HydraDxMath } from '../../math/useMath';\n\nexport const calculateOutGivenIn = (\n    math: HydraDxMath,\n    inReserve: string,\n    outReserve: string,\n    amountIn: string,\n) => math.xyk.calculate_out_given_in(inReserve, outReserve, amountIn);\n\nexport const calculateOutGivenInFromPool = (\n    math: HydraDxMath,\n    pool: XykPool,\n    assetInId: string,\n    assetOutId: string,\n    amountIn: string,\n) => {\n    const assetInBalance = find(pool.balances, { assetId: assetInId })?.balance;\n    const assetOutBalance = find(pool.balances, { assetId: assetOutId })?.balance\n\n    if (!assetInBalance || !assetOutBalance) throw new Error(`Can't find the required balances in the pool`);\n\n    return calculateOutGivenIn(math, assetInBalance, assetOutBalance, amountIn);\n}","import { find } from 'lodash';\nimport { LbpPool, Pool } from '../../../generated/graphql';\nimport { HydraDxMath } from '../../math/useMath';\n\n/**\n * Wrapper for `math.lbp.calculate_in_given_out`\n * @param math\n * @param inReserve \n * @param outReserve \n * @param inWeight \n * @param outWeight \n * @param amount \n * @returns \n */\nexport const calculateInGivenOut = (\n    math: HydraDxMath,\n    inReserve: string,\n    outReserve: string,\n    inWeight: string,\n    outWeight: string,\n    amount: string\n) => {\n    return math.lbp.calculate_in_given_out(inReserve, outReserve, inWeight, outWeight, amount);\n}\n\nexport const getPoolBalances = (pool: Pool, assetInId: string, assetOutId: string) => {\n    const assetABalance = find(pool.balances, { assetId: assetInId })?.balance;\n    const assetBBalance = find(pool.balances, { assetId: assetOutId })?.balance\n\n    return { assetABalance, assetBBalance }\n}\n\nexport const getInAndOutWeights = (pool: LbpPool, assetInId: string, assetOutId: string) => {\n    const assetInWeight = assetInId === pool.assetInId\n        ? pool.assetAWeights.current\n        : pool.assetBWeights.current\n\n    const assetOutWeight = assetOutId === pool.assetOutId\n        ? pool.assetBWeights.current\n        : pool.assetAWeights.current;\n\n    return { assetInWeight, assetOutWeight };\n}\n\nexport const calculateInGivenOutFromPool = (\n    math: HydraDxMath,\n    pool: LbpPool,\n    assetInId: string,\n    assetOutId: string,\n    amountOut: string,\n) => {\n    const { assetABalance: assetInBalance, assetBBalance: assetOutBalance } = getPoolBalances(\n        pool,\n        assetInId,\n        assetOutId,\n    )\n\n    if (!assetInBalance || !assetOutBalance) throw new Error(`Can't find the required balances in the pool`);\n\n    const { assetInWeight, assetOutWeight } = getInAndOutWeights(pool, assetInId, assetOutId);\n\n    return calculateInGivenOut(\n        math, \n        assetInBalance, \n        assetOutBalance,\n        assetInWeight,\n        assetOutWeight,\n        amountOut\n    );\n}","import { find } from 'lodash';\nimport { LbpPool } from '../../../generated/graphql';\nimport { HydraDxMath } from '../../math/useMath';\nimport { getInAndOutWeights, getPoolBalances } from './calculateInGivenOut';\n\n/**\n * Wrapper for `math.lbp.calculate_out_given_in`\n * @param math \n * @param inReserve \n * @param outReserve \n * @param inWeight \n * @param outWeight \n * @param amount \n * @returns \n */\nexport const calculateOutGivenIn = (\n    math: HydraDxMath,\n    inReserve: string,\n    outReserve: string,\n    inWeight: string,\n    outWeight: string,\n    amount: string,\n) => {\n    return math.lbp.calculate_out_given_in(inReserve, outReserve, inWeight, outWeight, amount);\n}\n\nexport const calculateOutGivenInFromPool = (\n    math: HydraDxMath,\n    pool: LbpPool,\n    assetInId: string,\n    assetOutId: string,\n    amountIn: string,\n) => {\n    const { assetABalance: assetInBalance, assetBBalance: assetOutBalance } = getPoolBalances(\n        pool,\n        assetInId,\n        assetOutId,\n    )\n\n    if (!assetInBalance || !assetOutBalance) throw new Error(`Can't find the required balances in the pool`);\n\n    const { assetInWeight, assetOutWeight } = getInAndOutWeights(pool, assetInId, assetOutId);\n\n    return calculateOutGivenIn(\n        math, \n        assetInBalance, \n        assetOutBalance,\n        assetInWeight,\n        assetOutWeight,\n        amountIn\n    );\n}","import { XykPool } from '../../../generated/graphql';\nimport { HydraDxMath } from '../../math/useMath';\nimport { getPoolBalances } from '../lbp/calculateInGivenOut';\n\nexport const calculateInGivenOut = (\n    math: HydraDxMath,\n    outReserve: string,\n    inReserve: string,\n    amountOut: string,\n) => math.xyk.calculate_in_given_out(outReserve, inReserve, amountOut);\n\nexport const calculateInGivenOutFromPool = (\n    math: HydraDxMath,\n    pool: XykPool,\n    assetInId: string,\n    assetOutId: string,\n    amountOut: string\n) => {\n    const { assetABalance: assetInBalance, assetBBalance: assetOutBalance } = getPoolBalances(\n        pool,\n        assetInId,\n        assetOutId,\n    )\n\n    if (!assetInBalance || !assetOutBalance) throw new Error(`Can't find the required balances in the pool`);\n\n    //TODO: argument order appears swapped when compared to the hydradx-math library\n    return calculateInGivenOut(math, assetInBalance, assetOutBalance, amountOut);\n}","import { Pool } from '../../generated/graphql';\n\n/**\n * Check if the given pool contains the selected assets\n * @param pool \n * @param assetInId \n * @param assetOutId \n * @returns \n */\nexport const poolHasAssets = (pool: Pool, assetInId: string, assetOutId: string) => {\n    const poolAssets = [pool.assetInId, pool.assetOutId];\n    return poolAssets.includes(assetInId) && poolAssets.includes(assetOutId);\n}","import BigNumber from 'bignumber.js'\nimport { useMemo } from 'react';\nimport { toPrecision12 } from './useToPrecision';\n\nexport const percentageChange = (a?: string | BigNumber, b?: string | BigNumber) => {\n    if (!a || !b) return;\n    \n    const aBN = new BigNumber(a);\n    const bBN = new BigNumber(b);\n\n    return (bBN.minus(aBN))\n        .dividedBy(aBN)\n}\nexport const usePercentageChange = (a?: string, b?: string) => (\n    useMemo(() => percentageChange(a, b), [{a, b}])\n)","import BigNumber from 'bignumber.js';\nimport { isNaN } from 'lodash';\nimport { useMemo } from 'react';\nimport { TradeType } from '../../../generated/graphql';\nimport { fromPrecision12 } from '../../../hooks/math/useFromPrecision';\nimport { percentageChange } from '../../../hooks/math/usePercentageChange';\nimport { toPrecision12 } from '../../../hooks/math/useToPrecision';\n\nexport interface Slippage {\n    percentualSlippage: string,\n    spotPriceAmount: string\n}\n\nexport const calculateSlippage = (\n    spotPrice: string,\n    assetInAmount: string,\n    assetOutAmount: string,\n) => {\n    const spotPriceAmount = new BigNumber(spotPrice)\n        .multipliedBy(\n            fromPrecision12(assetOutAmount)!\n        )\n        .toFixed(0);\n\n    const resultPercentageChange = percentageChange(\n        spotPriceAmount,\n        assetInAmount\n    );\n\n    if (!resultPercentageChange || resultPercentageChange.isNaN()) return;\n\n    // TODO: don't use this for every bignumber call\n    // TODO: fix edge cases for .09 decimal formatting\n    BigNumber.config({ ROUNDING_MODE: BigNumber.ROUND_UP });\n    const percentualSlippage = new BigNumber(resultPercentageChange)\n        .multipliedBy(100)\n        .abs()\n        .toFixed(10) // TODO: deal with formatting to 2 decimal places when displaying the result\n\n    const slippage: Slippage = {\n        percentualSlippage,\n        spotPriceAmount\n    }\n    return slippage\n}\n\n/**\n * Slippage is the percieved difference between\n * the given `spotPrice` and the given assetAmount`\n * \n * @param spotPrice\n * @param assetAmount \n * @returns \n */\nexport const useSlippage = (\n    tradeType: TradeType,\n    spotPrice?: {\n        aToB?: string,\n        bToA?: string\n    },\n    assetInAmount?: string,\n    assetOutAmount?: string,\n) => {\n    if (!spotPrice?.aToB || !spotPrice?.bToA || !assetInAmount || !assetOutAmount) return;\n    return calculateSlippage.apply(null,\n        tradeType === TradeType.Buy\n            ? [spotPrice.bToA, assetInAmount, assetOutAmount]\n            : [spotPrice.aToB, assetOutAmount, assetInAmount]\n    )\n}","import { Fee } from './generated/graphql';\n\nexport default {\n    appName: 'basilisk-ui',\n    xykFee: {\n        numerator: '2',\n        denominator: '1000'\n    } as Fee\n}","import BigNumber from 'bignumber.js';\nimport { Fee, LbpPool, Pool } from '../../../generated/graphql';\nimport constants from './../../../constants';\n\nexport const feeToPercentage = (fee: Fee) => {\n    return new BigNumber(fee.numerator)\n        .dividedBy(fee.denominator)\n        .multipliedBy('100')\n        .toFixed(2);\n}\n\nexport const feeFromPool = (pool?: Pool): Fee | undefined => {\n    return pool\n        ? (\n            pool.__typename === 'XYKPool'\n                ? constants.xykFee\n                : (pool as LbpPool).fee\n        ) : undefined\n}\n\nexport const usePercentageFee = (pool?: Pool) => {\n    const fee = feeFromPool(pool);\n    if (!fee) return;\n    return feeToPercentage(fee);\n} ","import { useEffect, useMemo } from 'react';\nimport { UseFormReturn } from 'react-hook-form';\nimport { Fee, LbpPool, Pool } from '../../../generated/graphql';\nimport { TradeFormFields } from './useTradeForm';\nimport BigNumber from 'bignumber.js';\nimport log from 'loglevel';\nimport { feeFromPool, feeToPercentage } from './usePercentageFee';\n\nexport const defaultAllowedSlippage = {\n    xyk: '5',\n    lbp: '5'\n}\n\nexport const addFeeToSlippage = (slippage: string, fee?: Fee) => {\n    if (!fee) return slippage;\n    \n    return new BigNumber(slippage).plus(\n        feeToPercentage(fee)\n    ).toFixed(2);\n}\n\nexport const useCalculateAllowedSlippage = (\n    form: UseFormReturn<TradeFormFields>,\n    pool?: Pool,\n) => {\n    const watchAutoSlippage = form.watch('autoSlippage');\n    const allowedSlippageInputDisabled = useMemo(() => (\n        form.getValues('autoSlippage')\n    ), [watchAutoSlippage]);\n\n    useEffect(() => {\n        if (!allowedSlippageInputDisabled) return;\n\n        // TODO: depending on if the LBP repay fee is applied,\n        // increase the lbp default slippage\n        const allowedSlippage = pool\n            ? (\n                pool?.__typename === 'XYKPool'\n                ? defaultAllowedSlippage.xyk\n                : defaultAllowedSlippage.lbp\n            ) : defaultAllowedSlippage.xyk;\n\n        const allowedSlippageWithFee = addFeeToSlippage(\n            allowedSlippage,\n            feeFromPool(pool)\n        )\n\n        log.debug('TradeForm.useCalculateAllowedSlippage', 'allowedSlippageWithFee', allowedSlippageWithFee);\n\n        form.setValue('allowedSlippage', allowedSlippageWithFee);\n    }, [pool, allowedSlippageInputDisabled])\n\n    return { allowedSlippageInputDisabled };\n}","import log from 'loglevel'\nimport { useCallback, useEffect, useMemo, useState } from 'react'\nimport { useForm, UseFormReturn } from 'react-hook-form'\nimport { usePreviousDistinct } from 'react-use'\nimport { PoolType } from '../../components/Chart/shared'\nimport { TokenInput } from '../../components/Input/TokenInput'\nimport { Pool, TradeType } from '../../generated/graphql'\nimport { useSubmitTradeMutation } from '../../hooks/pools/mutations/useSubmitTradeMutation'\nimport { calculateOutGivenInFromPool as calculateOutGivenInFromPoolXYK } from '../../hooks/pools/xyk/calculateOutGivenIn'\nimport { calculateOutGivenInFromPool as calculateOutGivenInFromPoolLBP } from '../../hooks/pools/lbp/calculateOutGivenIn'\nimport { useMathContext } from '../../hooks/math/useMath'\nimport { fromPrecision12 } from '../../hooks/math/useFromPrecision'\nimport { toPrecision12 } from '../../hooks/math/useToPrecision'\nimport { calculateInGivenOutFromPool as calculateInGivenOutFromPoolLBP } from '../../hooks/pools/lbp/calculateInGivenOut'\nimport { calculateInGivenOutFromPool as calculateInGivenOutFromPoolXYK } from '../../hooks/pools/xyk/calculateInGivenOut'\nimport { SpotPrice } from '../../pages/TradePage/TradePage'\nimport { useTradeForm } from './hooks/useTradeForm'\nimport { useListenForInput } from './hooks/useListenForInput'\nimport { useTradeType } from './hooks/useTradeType'\nimport { useHandleAssetIdsChange } from './hooks/useHandleAssetIdsChange'\nimport { useHandleSubmit } from './hooks/useHandleSubmit';\nimport { poolHasAssets } from '../../hooks/pools/poolHasAssets'\nimport { useCalculateInAndOut } from './hooks/useCalculateInAndOut'\nimport { useSlippage } from './hooks/useSlippage'\nimport { isEqual } from 'lodash'\nimport { useResetAmountInputsOnPoolChange } from './hooks/useResetAmountInputsOnPoolChange'\nimport { useCalculateAllowedSlippage } from './hooks/useCalculateAllowedSlippage'\nimport { usePercentageFee } from './hooks/usePercentageFee'\n\nexport interface TradeFormProps {\n    pool?: Pool,\n    loading: boolean,\n    assetIds: {\n        assetInId: string,\n        assetOutId?: string\n    },\n    spotPrice?: SpotPrice,\n    onAssetIdsChange: (assetInId: string, assetOutId?: string) => void\n}\n\nexport const TradeForm = ({\n    pool,\n    loading,\n    onAssetIdsChange,\n    assetIds,\n    spotPrice\n}: TradeFormProps) => {\n    const form = useTradeForm(assetIds);\n    const fee = usePercentageFee(pool);\n    const tradeType = useTradeType(form);\n    useHandleAssetIdsChange(form, onAssetIdsChange);\n    useCalculateInAndOut(form, tradeType, pool);\n    useResetAmountInputsOnPoolChange(form, pool);\n\n    // TODO: adjust the precision in the hook itself?\n    const slippage = useSlippage(tradeType, spotPrice, \n        toPrecision12(form.getValues('assetInAmount')),\n        toPrecision12(form.getValues('assetOutAmount'))\n    );\n\n    const handleSubmit = useHandleSubmit(\n        tradeType, \n        form.getValues('allowedSlippage'), \n        slippage, \n        pool\n    );\n\n    const { allowedSlippageInputDisabled } = useCalculateAllowedSlippage(form, pool);\n\n    return <div>\n        <form onSubmit={form.handleSubmit(handleSubmit)}>\n            <p>{tradeType}</p>\n            <TokenInput\n                assetIdInputProps={form.register('assetInId')}\n                assetAmountInputProps={form.register('assetInAmount')}\n            />\n\n            <br/>\n\n            <TokenInput\n                assetIdInputProps={form.register('assetOutId')}\n                assetAmountInputProps={form.register('assetOutAmount')}\n            />\n\n            <div>\n                <b>Allowed slippage</b><br/>\n                <input \n                    type=\"text\"\n                    disabled={allowedSlippageInputDisabled}\n                    {...form.register('allowedSlippage')}\n                />\n                <br/>\n                <b>Auto slippage</b> \n                <input type=\"checkbox\" {...form.register('autoSlippage')}/>\n            </div>\n\n            <br/>\n\n            <p>\n                <b>Slippage:</b> {slippage?.percentualSlippage} / {fromPrecision12(slippage?.spotPriceAmount)}\n            </p>\n            <p>\n                <b>Fee:</b> {fee}%\n            </p>\n\n            <button\n                disabled={loading}\n                type='submit'\n            >\n                Trade\n            </button>\n        </form>\n    </div>\n}","import log from 'loglevel';\nimport { useState, useEffect } from 'react';\nimport { UseFormReturn } from 'react-hook-form';\nimport { TradeType } from '../../../generated/graphql';\nimport { useListenForInput } from './useListenForInput';\nimport { TradeFormFields } from './useTradeForm';\n\n/**\n * Listen to changes to inputs within the trade form, and set the trade type\n * according to which input field has been interacted with last\n * @param form \n * @returns \n */\n export const useTradeType = (form: UseFormReturn<TradeFormFields>) => {\n    const [tradeType, setTradeType] = useState<TradeType>(TradeType.Sell);\n    \n    const watchassetInAmount = useListenForInput(form, 'assetInAmount');\n    const watchAassetInId = useListenForInput(form, 'assetInId');\n\n    const watchAassetOutAmount = useListenForInput(form, 'assetOutAmount');\n    const watchAassetOutId = useListenForInput(form, 'assetOutId');\n\n    useEffect(() => { \n        log.debug('TradeForm.setTradeType', TradeType.Sell)\n        setTradeType(TradeType.Sell) \n    }, [watchassetInAmount, watchAassetInId]);\n\n    useEffect(() => {\n        log.debug('TradeForm.setTradeType', TradeType.Buy)\n        setTradeType(TradeType.Buy) \n    }, [watchAassetOutAmount, watchAassetOutId]);\n\n    return tradeType;\n}","import log from 'loglevel';\nimport { useEffect } from 'react';\nimport { UseFormReturn } from 'react-hook-form';\nimport { TradeFormProps } from '../TradeForm';\nimport { TradeFormFields } from './useTradeForm';\n\n/**\n * Inform parent components about asset ID changes in the form\n * @param form \n * @param onAssetIdsChange \n */\n export const useHandleAssetIdsChange = (\n    form: UseFormReturn<TradeFormFields>,\n    onAssetIdsChange: TradeFormProps['onAssetIdsChange']\n) => {\n    const [assetInId, assetOutId] = form.watch(['assetInId', 'assetOutId']);\n    useEffect(() => {\n        log.debug('TradeForm.useHandleAssetIdsChange', assetInId, assetOutId);\n        onAssetIdsChange(assetInId, assetOutId);\n    }, [assetInId, assetOutId]);\n}","import { useMemo, useEffect } from 'react';\nimport { UseFormReturn } from 'react-hook-form';\nimport { Pool, TradeType } from '../../../generated/graphql';\nimport { useMathContext } from '../../../hooks/math/useMath';\nimport { toPrecision12 } from '../../../hooks/math/useToPrecision';\nimport { calculateOutGivenInFromPool as calculateOutGivenInFromPoolXYK } from '../../../hooks/pools/xyk/calculateOutGivenIn';\nimport { calculateOutGivenInFromPool as calculateOutGivenInFromPoolLBP } from '../../../hooks/pools/lbp/calculateOutGivenIn';\nimport { calculateInGivenOutFromPool as calculateInGivenOutFromPoolXYK } from '../../../hooks/pools/xyk/calculateInGivenOut';\nimport { calculateInGivenOutFromPool as calculateInGivenOutFromPoolLBP } from '../../../hooks/pools/lbp/calculateInGivenOut';\nimport { poolHasAssets } from '../../../hooks/pools/poolHasAssets';\nimport { fromPrecision12 } from '../../../hooks/math/useFromPrecision';\nimport log from 'loglevel';\nimport { TradeFormFields } from './useTradeForm';\n\n// TODO: loading state when calculating the fee\n/**\n * Calculate in/out amounts respectively for both XYK & LBP\n * @param form \n * @param tradeType \n * @param pool \n */\n export const useCalculateInAndOut = (\n    form: UseFormReturn<TradeFormFields>,\n    tradeType: TradeType,\n    pool?: Pool\n) => {\n    const { math } = useMathContext();\n    let [assetInId, assetInAmount] = form.watch(['assetInId', 'assetInAmount']);\n    let [assetOutId, assetOutAmount] = form.watch(['assetOutId', 'assetOutAmount']);\n    \n    // convert the user input to the required precision\n    assetInAmount = toPrecision12(assetInAmount);\n    assetOutAmount = toPrecision12(assetOutAmount);\n\n    const calculateOutGivenIn = useMemo(() => (\n        pool?.__typename === 'XYKPool'\n            ? calculateOutGivenInFromPoolXYK\n            : calculateOutGivenInFromPoolLBP\n    ), [pool])\n\n    const calculateInGivenOut = useMemo(() => (\n        pool?.__typename === 'XYKPool'\n            ? calculateInGivenOutFromPoolXYK\n            : calculateInGivenOutFromPoolLBP\n    ), [pool]);\n    \n    useEffect(() => {\n        if (!pool || !math || !assetOutId || !assetInAmount) return;\n        if (!poolHasAssets(pool, assetInId, assetOutId)) return;\n        if (tradeType !== TradeType.Sell) return;\n\n        const outAmount = calculateOutGivenIn(\n            math, \n            pool as any, \n            assetInId, \n            assetOutId, \n            assetInAmount\n        )\n        \n        /**\n         * if LBP && assetOut == accumulated asset then \n         * apply fee on top of outAmount\n         */\n\n        log.debug('TradeForm.useCalculateInAndOut', 'outAmount', outAmount);\n\n        form.setValue('assetOutAmount', fromPrecision12(outAmount));\n    }, [assetInAmount, assetInId, assetOutId, tradeType, pool])\n\n    useEffect(() => {\n        if (!pool || !math || !assetOutId || !assetOutAmount) return;\n        if (!poolHasAssets(pool, assetInId, assetOutId)) return;\n        if (tradeType !== TradeType.Buy) return;\n\n        // TODO: when LBP & assetOut === accumulated asset\n        // then calculateFee with assetOutAmount\n\n        /**\n         * when the case above happens, your trade happens at a worse spot price\n         * and the pool pays the repayFee on your behalf\n         */\n\n        const inAmount = calculateInGivenOut(\n            math, \n            pool as any, \n            assetInId, \n            assetOutId, \n            // difference between calc (assetOut+fee) and calc(assetOut) is the absolute fee\n            assetOutAmount //TODO: use assetOutAmount + fee\n        );\n        \n        log.debug('TradeForm.useCalculateInAndOut', 'inAmount', fromPrecision12(inAmount));\n\n        form.setValue('assetInAmount', fromPrecision12(inAmount));\n    }, [assetOutAmount, assetInId, assetOutId, tradeType, pool])\n}","import { isEqual } from 'lodash';\nimport { useEffect } from 'react';\nimport { UseFormReturn } from 'react-hook-form';\nimport { usePreviousDistinct } from 'react-use';\nimport { Pool } from '../../../generated/graphql';\nimport { TradeFormFields } from './useTradeForm';\n\nexport const useResetAmountInputsOnPoolChange = (\n    form: UseFormReturn<TradeFormFields>,\n    pool?: Pool\n) => {\n    const previousPoolId = usePreviousDistinct(pool?.id);\n    useEffect(() => {\n        if (!isEqual(previousPoolId, pool?.id)) {\n            form.resetField('assetInAmount');\n            form.resetField('assetOutAmount');\n        }\n    }, [previousPoolId, pool?.id])\n}","import { fromPrecision12 } from '../hooks/math/useFromPrecision'\nimport { SpotPrice } from '../pages/TradePage/TradePage'\n\nexport interface PoolLiquidity {\n    assetABalance?: string,\n    assetBBalance?: string,\n}\nexport interface TradeChartProps {\n    spotPrice?: SpotPrice,\n    poolLiquidity: PoolLiquidity\n}\nexport const TradeChart = ({ spotPrice, poolLiquidity }: TradeChartProps) => {\n    return <div>\n        <p>TradeChart</p>\n        <div>\n            <b>Spot price</b><br/>\n            <span>1 A = {fromPrecision12(spotPrice?.aToB)}B</span><br/>\n            <span>1 B = {fromPrecision12(spotPrice?.bToA)}A</span>\n            \n            <br/><br/>\n\n            <b>Pool liquidity</b><br/>\n            <span>A = {fromPrecision12(poolLiquidity.assetABalance)}</span><br/>\n            <span>B = {fromPrecision12(poolLiquidity.assetBBalance)}</span>\n\n            <br/><br/>\n        </div>\n    </div>\n}","import { find } from 'lodash';\nimport { useMemo } from 'react';\nimport { LbpPool } from '../../../generated/graphql';\nimport { HydraDxMath, useMathContext } from '../../math/useMath';\n\nexport const oneWithPrecision = '1000000000000'; // 10^12 doesnt work, use 10^9 instead\n\nexport const calculateSpotPrice = (\n    math: HydraDxMath,\n    inReserve: string,\n    outReserve: string,\n    inWeight: string,\n    outWeight: string,\n    amount: string = oneWithPrecision,\n) => math.lbp.get_spot_price(inReserve, outReserve, inWeight, outWeight, amount);\n\nexport const calculateSpotPriceFromPool = (\n    math: HydraDxMath,\n    pool: LbpPool,\n    assetInId: string,\n    assetOutId: string,\n) => {\n    const assetInBalance = find(pool.balances, { assetId: assetInId })?.balance;\n    const assetOutBalance = find(pool.balances, { assetId: assetOutId })?.balance\n\n    if (!assetInBalance || !assetOutBalance) throw new Error(`Can't find the required balances in the pool`);\n\n    const assetInWeight = assetInId === pool.assetInId\n        ? pool.assetAWeights.current\n        : pool.assetBWeights.current\n\n    const assetOutWeight = assetOutId === pool.assetOutId\n        ? pool.assetBWeights.current\n        : pool.assetAWeights.current;\n\n    return calculateSpotPrice(\n        math, \n        assetInBalance, \n        assetOutBalance,\n        assetInWeight,\n        assetOutWeight,\n    );\n}\n","import { find } from 'lodash';\nimport { XykPool } from '../../../generated/graphql';\nimport { HydraDxMath } from '../../math/useMath';\nimport { oneWithPrecision } from '../lbp/calculateSpotPrice';\n\nexport const calculateSpotPrice = (\n    math: HydraDxMath,\n    inReserve: string,\n    outReserve: string,\n) => math.xyk.get_spot_price(inReserve, outReserve, oneWithPrecision);\n\nexport const calculateSpotPriceFromPool = (\n    math: HydraDxMath,\n    pool: XykPool,\n    assetInId: string,\n    assetOutId: string,\n) => {\n    const assetInBalance = find(pool.balances, { assetId: assetInId })?.balance;\n    const assetOutBalance = find(pool.balances, { assetId: assetOutId })?.balance\n\n    if (!assetInBalance || !assetOutBalance) return;\n\n    return calculateSpotPrice(\n        math,\n        assetInBalance,\n        assetOutBalance\n    )\n}","import { find, isEqual } from 'lodash';\nimport { useMemo, useState } from 'react';\nimport { useGetPoolByAssetsQuery } from '../../hooks/pools/queries/useGetPoolByAssetsQuery';\nimport { TradeForm, TradeFormProps } from '../../containers/TradeForm/TradeForm';\nimport { PoolLiquidity, TradeChart } from '../../containers/TradeChart';\nimport log from 'loglevel';\nimport { useSpotPrice } from './hooks/useSpotPrice';\nimport { usePreviousDistinct } from 'react-use';\nimport { Pool } from '../../generated/graphql';\n\nexport interface SpotPrice {\n    aToB?: string,\n    bToA?: string\n}\n\n/**\n * Trade page responsible for fetching pool data\n * @returns \n */\nexport const TradePage = () => {\n    // TODO default values here should come from the router where query args are parsed\n    const [assetIds, setAssetIds] = useState<TradeFormProps['assetIds']>({\n        assetInId: '0',\n        assetOutId: '2'\n    })\n\n    // automatically fetch a pool by the given assets\n    const { \n        data: poolData, \n        loading: poolLoading, \n        error: poolError \n    } = useGetPoolByAssetsQuery(assetIds);\n    log.debug('TradePage.useGetPoolByAssetsQuery', assetIds);\n\n    const pool: Pool | undefined = useMemo(() => poolData?.pool, [poolData?.pool]);\n\n    // if there was a problem fetching the pool, log it\n    poolError && log.error(poolError);\n\n    // combined loading state from all the required queries\n    const loading = useMemo(() => {\n        const loading = poolLoading;\n        log.debug('TradePage.loading', loading);\n        return loading;\n    }, [poolLoading]);\n\n    log.debug('TradePage.poolData.pool', poolData?.pool);\n\n    // when the underlying form's assetIds change, update the state\n    const handleAssetIdsChange = (assetInId: string, assetOutId?: string) => {\n        const newIds = { assetInId, assetOutId };\n        log.debug('TradePage.handleAssetIdsChange', isEqual(assetIds, newIds), newIds);\n        if (!isEqual(assetIds, newIds)) setAssetIds(newIds);\n    }\n\n    const spotPrice = useSpotPrice(\n        assetIds,\n        poolData?.pool\n    );\n\n    const poolLiquidity: PoolLiquidity = useMemo(() => {\n        return {\n            assetABalance: find(pool?.balances, { assetId: assetIds.assetInId })?.balance,\n            assetBBalance: find(pool?.balances, { assetId: assetIds.assetOutId })?.balance,\n        }\n    }, [pool]);\n\n    return <div>\n        <h1>Trade</h1>\n\n        <br /><br />\n\n        <TradeChart\n            poolLiquidity={poolLiquidity}\n            spotPrice={spotPrice}\n        />\n        \n        <TradeForm\n            onAssetIdsChange={handleAssetIdsChange}\n            assetIds={assetIds}\n            loading={loading}\n            pool={pool}\n            spotPrice={spotPrice}\n        />\n    </div>\n}","import { useApolloClient } from '@apollo/client';\nimport { useMemo } from 'react';\nimport { TradeFormProps } from '../../../containers/TradeForm/TradeForm';\nimport { Pool } from '../../../generated/graphql';\nimport { readLastBlock } from '../../../hooks/lastBlock/readLastBlock';\nimport { useMathContext } from '../../../hooks/math/useMath';\nimport { SpotPrice } from '../TradePage';\nimport { calculateSpotPriceFromPool as calculateSpotPriceFromPoolLBP } from '../../../hooks/pools/lbp/calculateSpotPrice';\nimport { calculateSpotPriceFromPool as calculateSpotPriceFromPoolXYK } from '../../../hooks/pools/xyk/calculateSpotPrice';\nimport log from 'loglevel';\n\nexport const useSpotPrice = (\n  { assetInId, assetOutId }: TradeFormProps['assetIds'],\n  pool?: Pool\n): SpotPrice | undefined => {\n  const client = useApolloClient();\n  const relaychainBlockNumber = readLastBlock(client.cache);\n  const { math } = useMathContext();\n\n  return useMemo(() => {\n    if (!math || !pool || !assetInId || !assetOutId || !relaychainBlockNumber)\n      return;\n\n    // if the pool is an XYKPool, use the XYKPool spot price calculation and vice versa\n    const calculateSpotPriceFromPool =\n      pool?.__typename === 'XYKPool'\n        ? calculateSpotPriceFromPoolXYK\n        : calculateSpotPriceFromPoolLBP;\n\n    const spotPrice: SpotPrice = {\n      // TODO: get rid of `as any` since its not type safe *at all*\n      aToB: calculateSpotPriceFromPool(\n        math,\n        pool as any,\n        assetInId,\n        assetOutId\n      ),\n      bToA: calculateSpotPriceFromPool(\n        math,\n        pool as any,\n        assetOutId,\n        assetInId\n      ),\n    };\n\n    log.debug('TradePage.useSpotPrice', spotPrice);\n\n    return spotPrice;\n  }, [relaychainBlockNumber, assetInId, assetOutId, pool, math]);\n};\n","import { useMutation } from '@apollo/client';\nimport { loader } from 'graphql.macro';\nimport { GET_ACTIVE_ACCOUNT } from '../queries/useGetActiveAccountQuery';\n\nexport const SET_ACTIVE_ACCOUNT = loader('./../graphql/SetActiveAccount.mutation.graphql');\n\nexport interface SetActiveAccountMutationVariables {\n    id: string | undefined\n}\n\nexport const useSetActiveAccountMutation = (variables: SetActiveAccountMutationVariables) => useMutation<void, SetActiveAccountMutationVariables>(\n    SET_ACTIVE_ACCOUNT,\n    {\n        variables,\n        refetchQueries: [\n            // TODO: figure out why do we need to refetch active account manually,\n            // while all accounts query gets updated automatically\n            GET_ACTIVE_ACCOUNT\n        ]\n    }\n)","import { useMemo } from 'react';\nimport { Account as AccountModel } from '../generated/graphql';\nimport { useSetActiveAccountMutation } from '../hooks/accounts/mutations/useSetActiveAccountMutation';\nimport { useGetAccountsQuery } from '../hooks/accounts/queries/useGetAccountsQuery'\nimport { useGetExtensionQuery } from '../hooks/polkadotJs/useGetExtensionQuery';\n\nexport const Account = ({ account }: { account?: AccountModel }) => {\n    // TODO: you can get the loading state of the mutation here as well\n    // but it probably needs to be turned into a contextual mutation\n    // in order to share the loading state accross multiple mutation hook calls\n    const [setActiveAccount] = useSetActiveAccountMutation({\n        id: account?.id\n    });\n\n    const [unsetActiveAccount] = useSetActiveAccountMutation({\n        id: undefined\n    });\n\n    return (\n        <div style={{\n            marginBottom: '24px',\n            padding: '12px',\n            paddingLeft: 0\n        }}>\n            <h3>\n                {account?.name}\n                {account?.isActive\n                    ? ' [active]'\n                    : <></>\n                }\n            </h3>\n            <p>\n                <b>Address:</b>\n                {account?.id}\n            </p>\n            <div>\n                <b>Balances:</b>\n                {account?.balances.map((balance, i) => (\n                    <p key={i}>\n                        {balance.assetId}:\n                        <i> {balance.balance}</i>\n                    </p>\n                ))}\n            </div>\n            <button\n                onClick={_ => account?.isActive ? unsetActiveAccount() : setActiveAccount()}\n            >\n                {account?.isActive ? 'Unset active' : 'Set active'}\n            </button>\n        </div>\n    )\n}\n\nexport const WalletPage = () => {\n    const { data: accountsData, loading: accountsLoading } = useGetAccountsQuery();\n    const { data: extensionData, loading: extensionLoading } = useGetExtensionQuery();\n\n    const loading = useMemo(() => {\n        return accountsLoading || extensionLoading;\n    }, [accountsLoading, extensionLoading])\n\n    return <div style={{\n        textAlign: 'left'\n    }}>\n        <h1>Accounts</h1>\n\n        {loading\n            ? <i>[WalletPage] Loading accounts...</i>\n            : <i>[WalletPage] Everything is up to date</i>\n        }\n\n        <br /><br />\n\n        {extensionData?.extension.isAvailable\n            ? (\n                <div>\n                    {accountsData?.accounts?.map((account, i) => (\n                        <Account\n                            key={i}\n                            account={account}\n                        />\n                    ))}\n                </div>\n            )\n            : <p>Extension unavailable</p>\n        }\n    </div>\n}","import { useApolloClient, useQuery } from '@apollo/client';\nimport { loader } from 'graphql.macro';\nimport { Query } from '../../../generated/graphql';\nimport { useEffect } from 'react';\nimport { removeUserAction } from '../helpers/removeUserAction';\nimport { readActiveAccount } from '../../accounts/readActiveAccount';\n\nexport const GET_USER_ACTIONS = loader(\n  '../graphql/GetUserActions.query.graphql'\n);\n\nexport interface GetUserActionsQueryVariables {\n  id: string;\n  account: string;\n}\n\nexport interface UseGetUserActionsQuery {\n  userActions: Query['userActions'];\n}\nexport const useGetUserActions = () => {\n  const client = useApolloClient();\n\n  const account = readActiveAccount(client.cache);\n  const address = account?.id;\n\n  if (!address) {\n    // TODO: WHAT DO ?\n  }\n\n  const result = useQuery<UseGetUserActionsQuery>(GET_USER_ACTIONS, {\n    notifyOnNetworkStatusChange: true,\n    returnPartialData: true,\n    pollInterval: 5000,\n    variables: {\n      account: address,\n    },\n  });\n\n  useEffect(() => {\n    result.data?.userActions?.forEach((value) => {\n      removeUserAction(client.cache, value.id);\n    });\n  }, [client.cache, result.data?.userActions]);\n\n  return result;\n};\n","import { ApolloCache } from '@apollo/client';\nimport { __typename } from '../resolvers/useGetActionLogQueryResolver';\n\nexport const removeUserAction = (cache: ApolloCache<object>, id: string) => {\n  cache.evict({ id: cache.identify({ id: id, __typename }) });\n};\n","import { useGetActionLogQuery } from '../hooks/actionLog/queries/useGetActionLogQuery';\nimport { useGetUserActions } from '../hooks/actionLog/queries/useGetUserActionsQuery';\nimport { useMemo } from 'react';\nimport { UserAction } from '../generated/graphql';\nimport { cloneDeep } from 'lodash';\n\nexport const __typename: UserAction['__typename'] = 'UserAction';\n\nexport const ActionLogPage = () => {\n  const { data: clientActionLogData, loading: clientLoading } =\n    useGetActionLogQuery();\n  const { data: actionLogData, loading } = useGetUserActions();\n\n  const cachedData = useMemo(\n    () => clientActionLogData?.actionLog,\n    [clientActionLogData?.actionLog]\n  );\n  const userActions = useMemo(\n    () => actionLogData?.userActions,\n    [actionLogData?.userActions]\n  );\n\n  const data = useMemo(() => {\n    if (cachedData && cachedData.length > 0) {\n      let d = cloneDeep(userActions) || [];\n\n      cachedData.forEach((action) => {\n        d.unshift({ ...action, __typename });\n      });\n\n      return d;\n    } else {\n      return userActions || [];\n    }\n  }, [cachedData, userActions]);\n\n  return (\n    <div\n      style={{\n        textAlign: 'left',\n      }}\n    >\n      <h1>ActionLog</h1>\n\n      {loading || clientLoading ? (\n        <i>[WalletPage] Loading action log...</i>\n      ) : (\n        <i>[WalletPage] Everything is up to date</i>\n      )}\n\n      <br />\n      <br />\n\n      {data.map((action, i) => (\n        <p>\n          {i} : {action.action} - {action.status} - {action.id}\n        </p>\n      ))}\n    </div>\n  );\n};\n","import { Routes, Route, Navigate } from 'react-router-dom';\nimport { TradePage } from '../pages/TradePage/TradePage';\nimport { WalletPage } from '../pages/WalletPage';\nimport { ActionLogPage } from '../pages/ActionLogPage';\n\nexport const Router = () => {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<TradePage />} />\n      <Route path=\"wallet\" element={<WalletPage />} />\n      <Route path=\"log\" element={<ActionLogPage />} />\n      <Route path=\"*\" element={<Navigate to=\"/\" />} />\n    </Routes>\n  );\n};\n","import './ActionBar.scss';\nimport { Link } from 'react-router-dom';\n\nexport interface ActionBarProps {\n    isExtensionAvailable: boolean;\n  extensionLoading: boolean;\n  activeAccountLoading: boolean;\n  accountData?: {\n          name?: string;\n          address?: string;\n          nativeAssetBalance?: string;\n  };\n}\n\nexport const ActionBar = ({\n  extensionLoading,\n  activeAccountLoading,\n  accountData,\n  isExtensionAvailable,\n}: ActionBarProps) => {\n  return (\n    <div className=\"action-bar\">\n      <div className='action-bar-icons action-bar-item'>\n        <div className=\"action-bar-help action-bar-icon \">?</div>\n        <div className=\"action-bar-notifications action-bar-icon \">!</div>\n      </div>\n      <div>\n        {extensionLoading || activeAccountLoading ? (\n          <div className='action-bar-error action-bar-item'>loading...</div>\n        ) : isExtensionAvailable ? (\n          <>\n            {accountData?.name ? (\n                <div className='action-bar-account-info action-bar-item'>\n                    <div className='action-bar-account-balance action-bar-account-item'>\n                        {accountData?.nativeAssetBalance} BSX\n                    </div>\n                    {/* TODO! Acc name / address + Icon component*/}\n                    <div className='action-bar-account-name action-bar-account-item'>\n                        {accountData?.name}\n                    </div>\n                </div>\n            ) : (\n              <Link className='action-bar-select-account action-bar-item' to=\"/wallet\">select an account</Link>\n            )}\n          </>\n        ) : (\n          <div className='action-bar-error action-bar-item'>Extension unavailable</div>\n        )}\n      </div>\n      <div className='action-bar-settings action-bar-item'>v</div>\n    </div>\n  );\n};\n","import React, { useState } from 'react';\nimport './Navigation.scss';\nimport { Link } from 'react-router-dom';\n\nexport const Modal = ({ children }: { children: React.ReactNode }) => {\n  return (\n    <div>\n      <h1>modal</h1>\n      {children}\n      <button>click me</button>\n    </div>\n  );\n};\n\nexport const ConfigModal = () => <h1>Config</h1>;\n\nexport const useModal = (content: React.ReactNode) => {\n  const [show, setShow] = useState<boolean>(false);\n\n  return {\n    modal: show ? <Modal>{content}</Modal> : <></>,\n    toggleModal: () => setShow((show) => !show),\n  };\n};\n\nexport const Navigation = () => (\n  <div>\n    <Link className=\"basilisk-logo\" to=\"https://bsx.fi\">\n      ()\n    </Link>\n    <Link to=\"/\">Trade</Link>\n    {' | '}\n    <Link to=\"/\">Pools</Link>\n    {' | '}\n    <Link to=\"/wallet\">Wallet</Link>\n    {' | '}\n    <Link to=\"/log\">Action Log</Link>\n  </div>\n);\n\nexport const NavigationContainer = () => {\n  return <Navigation />;\n};\n","import { first } from 'lodash';\nimport { useMemo } from 'react';\nimport { ActionBar } from '../components/Navigation/ActionBar';\nimport { Navigation } from '../components/Navigation/Navigation';\nimport { useGetActiveAccountQuery } from '../hooks/accounts/queries/useGetActiveAccountQuery';\nimport { nativeAssetId } from '../hooks/balances/useGetBalancesByAddress';\nimport { useLastBlockQuery } from '../hooks/lastBlock/useLastBlockQuery';\nimport { useGetExtensionQuery } from '../hooks/polkadotJs/useGetExtensionQuery';\n\nimport './TopBar.scss';\n\nexport const TopBar = () => {\n    // TODO: there is no loading state for last block\n    // since its populated in the cache manually\n    const { data: lastBlockData } = useLastBlockQuery();\n    const { data: activeAccountData, loading: activeAccountLoading, error } = useGetActiveAccountQuery();\n    const { data: extensionData, loading: extensionLoading } = useGetExtensionQuery();\n\n    error && console.error(error);\n    \n    // TODO: should probably be showing the fee payment asset here\n    const nativeAssetBalance = useMemo(() => (\n        first(\n            activeAccountData?.account?.balances\n                ?.filter(balance => balance.assetId === nativeAssetId)\n        )?.balance\n    ), [activeAccountData])\n\n    return (\n        <div className='top-bar'>\n            <Navigation />\n            \n            <div>\n                <b>Last block: </b>\n                {lastBlockData?.lastBlock?.parachainBlockNumber\n                    ? `#${lastBlockData?.lastBlock?.parachainBlockNumber} / #${lastBlockData?.lastBlock?.relaychainBlockNumber}`\n                    : 'loading...'\n                }\n            </div>\n                \n            <ActionBar {...{\n                isExtensionAvailable: !!extensionData && !!extensionData.extension?.isAvailable,\n                extensionLoading,\n                activeAccountLoading,\n                accountData: activeAccountData ? { \n                    name: activeAccountData.account ? activeAccountData.account.name ? activeAccountData.account.name : undefined  : undefined,\n                    nativeAssetBalance,\n                    address: 'placeholder fill me'\n                } : undefined\n            }}/>                \n        </div>\n    )\n}","import React from 'react'\nimport { useLoading } from '../hooks/misc/useLoading'\nimport { TopBar } from './TopBar'\n\nexport const PageContainer = ({ children }: { children: React.ReactNode }) => {\n    const loading = useLoading();\n    return (\n        <div style={{\n            padding: '24px',\n            width: '650px',\n            margin: '0 auto'\n        }}>\n            <TopBar />\n            {loading\n                ? <div style={{\n                    width: '100%',\n                    textAlign: 'center',\n                }}>\n                    <i>Connecting to the node...</i>\n                </div>\n                : children\n            }\n        </div>\n    )\n}","import { useMathContext } from '../math/useMath';\nimport { usePolkadotJsContext } from '../polkadotJs/usePolkadotJs'\n\nexport const useLoading = () => {\n    const { apiInstance } = usePolkadotJsContext();\n    const { math } = useMathContext();\n    return !apiInstance || !math;\n}","import './App.scss';\nimport { MultiProvider } from './containers/MultiProvider';\nimport log from 'loglevel';\nimport { BrowserRouter } from 'react-router-dom';\nimport { Router } from './containers/Router';\nimport { PageContainer } from './containers/PageContainer';\n\nlog.setLevel('debug');\n\nexport const branch = process.env.REACT_APP_GIT_BRANCH;\nexport const baseName = branch?.length ? `basilisk-ui/${branch}/app` : undefined;\n\nexport const App = () => {\n  return (\n    <MultiProvider>\n      <BrowserRouter basename={baseName}>\n        <PageContainer>\n          <Router />\n        </PageContainer>\n      </BrowserRouter>\n    </MultiProvider>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport './index.scss';\n\nReactDOM.render(\n  // TODO: figure out a way to enable react strict mode\n  // without triggering duplicate graphql queries\n  // https://github.com/apollographql/react-apollo/issues/3906#issuecomment-636604835\n  // <React.StrictMode>\n    <App/>,\n  // </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}